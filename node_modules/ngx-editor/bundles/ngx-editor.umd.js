(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('@angular/core'), require('@angular/forms'), require('prosemirror-state'), require('prosemirror-view'), require('prosemirror-model'), require('prosemirror-schema-list'), require('rxjs'), require('ngx-editor/plugins'), require('@angular/common'), require('prosemirror-commands'), require('ngx-editor/helpers'), require('ngx-editor/commands'), require('@angular/platform-browser')) :
    typeof define === 'function' && define.amd ? define('ngx-editor', ['exports', '@angular/core', '@angular/forms', 'prosemirror-state', 'prosemirror-view', 'prosemirror-model', 'prosemirror-schema-list', 'rxjs', 'ngx-editor/plugins', '@angular/common', 'prosemirror-commands', 'ngx-editor/helpers', 'ngx-editor/commands', '@angular/platform-browser'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global['ngx-editor'] = {}, global.ng.core, global.ng.forms, global.prosemirrorState, global.prosemirrorView, global.prosemirrorModel, global.prosemirrorSchemaList, global.rxjs, global['ngx-editor'].plugins, global.ng.common, global.prosemirrorCommands, global['ngx-editor'].helpers, global['ngx-editor'].commands, global.ng.platformBrowser));
}(this, (function (exports, i0, forms, prosemirrorState, prosemirrorView, prosemirrorModel, sl, rxjs, plugins, common, prosemirrorCommands, helpers, commands, platformBrowser) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */
    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b)
                if (Object.prototype.hasOwnProperty.call(b, p))
                    d[p] = b[p]; };
        return extendStatics(d, b);
    };
    function __extends(d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    var __assign = function () {
        __assign = Object.assign || function __assign(t) {
            for (var s, i = 1, n = arguments.length; i < n; i++) {
                s = arguments[i];
                for (var p in s)
                    if (Object.prototype.hasOwnProperty.call(s, p))
                        t[p] = s[p];
            }
            return t;
        };
        return __assign.apply(this, arguments);
    };
    function __rest(s, e) {
        var t = {};
        for (var p in s)
            if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
                t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
                if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                    t[p[i]] = s[p[i]];
            }
        return t;
    }
    function __decorate(decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
            r = Reflect.decorate(decorators, target, key, desc);
        else
            for (var i = decorators.length - 1; i >= 0; i--)
                if (d = decorators[i])
                    r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    }
    function __param(paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); };
    }
    function __metadata(metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function")
            return Reflect.metadata(metadataKey, metadataValue);
    }
    function __awaiter(thisArg, _arguments, P, generator) {
        function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try {
                step(generator.next(value));
            }
            catch (e) {
                reject(e);
            } }
            function rejected(value) { try {
                step(generator["throw"](value));
            }
            catch (e) {
                reject(e);
            } }
            function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    }
    function __generator(thisArg, body) {
        var _ = { label: 0, sent: function () { if (t[0] & 1)
                throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function () { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f)
                throw new TypeError("Generator is already executing.");
            while (_)
                try {
                    if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
                        return t;
                    if (y = 0, t)
                        op = [op[0] & 2, t.value];
                    switch (op[0]) {
                        case 0:
                        case 1:
                            t = op;
                            break;
                        case 4:
                            _.label++;
                            return { value: op[1], done: false };
                        case 5:
                            _.label++;
                            y = op[1];
                            op = [0];
                            continue;
                        case 7:
                            op = _.ops.pop();
                            _.trys.pop();
                            continue;
                        default:
                            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                                _ = 0;
                                continue;
                            }
                            if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) {
                                _.label = op[1];
                                break;
                            }
                            if (op[0] === 6 && _.label < t[1]) {
                                _.label = t[1];
                                t = op;
                                break;
                            }
                            if (t && _.label < t[2]) {
                                _.label = t[2];
                                _.ops.push(op);
                                break;
                            }
                            if (t[2])
                                _.ops.pop();
                            _.trys.pop();
                            continue;
                    }
                    op = body.call(thisArg, _);
                }
                catch (e) {
                    op = [6, e];
                    y = 0;
                }
                finally {
                    f = t = 0;
                }
            if (op[0] & 5)
                throw op[1];
            return { value: op[0] ? op[1] : void 0, done: true };
        }
    }
    var __createBinding = Object.create ? (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        Object.defineProperty(o, k2, { enumerable: true, get: function () { return m[k]; } });
    }) : (function (o, m, k, k2) {
        if (k2 === undefined)
            k2 = k;
        o[k2] = m[k];
    });
    function __exportStar(m, o) {
        for (var p in m)
            if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p))
                __createBinding(o, m, p);
    }
    function __values(o) {
        var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
        if (m)
            return m.call(o);
        if (o && typeof o.length === "number")
            return {
                next: function () {
                    if (o && i >= o.length)
                        o = void 0;
                    return { value: o && o[i++], done: !o };
                }
            };
        throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    }
    function __read(o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m)
            return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
                ar.push(r.value);
        }
        catch (error) {
            e = { error: error };
        }
        finally {
            try {
                if (r && !r.done && (m = i["return"]))
                    m.call(i);
            }
            finally {
                if (e)
                    throw e.error;
            }
        }
        return ar;
    }
    function __spread() {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    }
    function __spreadArrays() {
        for (var s = 0, i = 0, il = arguments.length; i < il; i++)
            s += arguments[i].length;
        for (var r = Array(s), k = 0, i = 0; i < il; i++)
            for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
                r[k] = a[j];
        return r;
    }
    ;
    function __await(v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    }
    function __asyncGenerator(thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n])
            i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try {
            step(g[n](v));
        }
        catch (e) {
            settle(q[0][3], e);
        } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length)
            resume(q[0][0], q[0][1]); }
    }
    function __asyncDelegator(o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; } : f; }
    }
    function __asyncValues(o) {
        if (!Symbol.asyncIterator)
            throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator], i;
        return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
        function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
        function settle(resolve, reject, d, v) { Promise.resolve(v).then(function (v) { resolve({ value: v, done: d }); }, reject); }
    }
    function __makeTemplateObject(cooked, raw) {
        if (Object.defineProperty) {
            Object.defineProperty(cooked, "raw", { value: raw });
        }
        else {
            cooked.raw = raw;
        }
        return cooked;
    }
    ;
    var __setModuleDefault = Object.create ? (function (o, v) {
        Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function (o, v) {
        o["default"] = v;
    };
    function __importStar(mod) {
        if (mod && mod.__esModule)
            return mod;
        var result = {};
        if (mod != null)
            for (var k in mod)
                if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
                    __createBinding(result, mod, k);
        __setModuleDefault(result, mod);
        return result;
    }
    function __importDefault(mod) {
        return (mod && mod.__esModule) ? mod : { default: mod };
    }
    function __classPrivateFieldGet(receiver, privateMap) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to get private field on non-instance");
        }
        return privateMap.get(receiver);
    }
    function __classPrivateFieldSet(receiver, privateMap, value) {
        if (!privateMap.has(receiver)) {
            throw new TypeError("attempted to set private field on non-instance");
        }
        privateMap.set(receiver, value);
        return value;
    }

    var defaults = {
        // menu
        bold: 'Bold',
        italic: 'Italic',
        code: 'Code',
        underline: 'Underline',
        strike: 'Strike',
        blockquote: 'Blockquote',
        bullet_list: 'Bullet List',
        ordered_list: 'Ordered List',
        heading: 'Heading',
        h1: 'Header 1',
        h2: 'Header 2',
        h3: 'Header 3',
        h4: 'Header 4',
        h5: 'Header 5',
        h6: 'Header 6',
        align_left: 'Left Align',
        align_center: 'Center Align',
        align_right: 'Right Align',
        align_justify: 'Justify',
        text_color: 'Text Color',
        background_color: 'Background Color',
        // pupups, forms, others...
        url: 'URL',
        text: 'Text',
        openInNewTab: 'Open in new tab',
        insert: 'Insert',
        altText: 'Alt Text',
        title: 'Title',
        remove: 'Remove',
    };
    var Locals = /** @class */ (function () {
        function Locals(newLocals) {
            var _this = this;
            if (newLocals === void 0) { newLocals = {}; }
            this.locals = defaults;
            this.get = function (key) {
                var _a;
                return (_a = _this.locals[key]) !== null && _a !== void 0 ? _a : '';
            };
            this.locals = Object.assign({}, defaults, newLocals);
        }
        return Locals;
    }());

    var camelToDashed = function (str) {
        return str.replace(/[A-Z]/g, function (m) { return '-' + m.toLowerCase(); });
    };
    var ɵ0 = camelToDashed;
    var cleanObject = function (obj) {
        var cleanObj = {};
        Object.keys(obj).forEach(function (prop) {
            if (obj[prop]) {
                cleanObj[prop] = obj[prop];
            }
        });
        return cleanObj;
    };
    var ɵ1 = cleanObject;
    var toStyleString = function (obj) {
        var styles = cleanObject(obj);
        return Object.entries(styles).map(function (_a) {
            var _b = __read(_a, 2), k = _b[0], v = _b[1];
            return camelToDashed(k) + ":" + v;
        }).join(';');
    };
    var ɵ2 = toStyleString;

    var doc = {
        content: 'block+'
    };
    // :: NodeSpec The text node.
    var text = {
        group: 'inline'
    };
    // :: NodeSpec A plain paragraph textblock. Represented in the DOM
    // as a `<p>` element.
    var paragraph = {
        content: 'inline*',
        group: 'block',
        attrs: {
            align: {
                default: null,
            }
        },
        parseDOM: [
            {
                tag: 'p',
                getAttrs: function (dom) {
                    var textAlign = dom.style.textAlign;
                    var align = dom.getAttribute('align') || textAlign || null;
                    return {
                        align: align
                    };
                }
            }
        ],
        toDOM: function (node) {
            var align = node.attrs.align;
            var styles = {
                textAlign: align !== 'left' ? align : null
            };
            var style = toStyleString(styles) || null;
            return ['p', { style: style }, 0];
        }
    };
    // :: NodeSpec A blockquote (`<blockquote>`) wrapping one or more blocks.
    var blockquote = {
        content: 'block+',
        group: 'block',
        defining: true,
        parseDOM: [{ tag: 'blockquote' }],
        toDOM: function () {
            return ['blockquote', 0];
        }
    };
    // :: NodeSpec A horizontal rule (`<hr>`).
    var horizontalRule = {
        group: 'block',
        parseDOM: [{ tag: 'hr' }],
        toDOM: function () {
            return ['hr'];
        }
    };
    // :: NodeSpec A heading textblock, with a `level` attribute that
    // should hold the number 1 to 6. Parsed and serialized as `<h1>` to
    // `<h6>` elements.
    var heading = {
        attrs: {
            level: {
                default: 1
            },
            align: {
                default: null,
            }
        },
        content: 'inline*',
        group: 'block',
        defining: true,
        parseDOM: [
            {
                tag: 'h1',
                getAttrs: function (dom) {
                    var textAlign = dom.style.textAlign;
                    var align = dom.getAttribute('align') || textAlign || null;
                    return {
                        level: 1,
                        align: align
                    };
                }
            },
            {
                tag: 'h2',
                getAttrs: function (dom) {
                    var textAlign = dom.style.textAlign;
                    var align = dom.getAttribute('align') || textAlign || null;
                    return {
                        level: 2,
                        align: align
                    };
                }
            },
            {
                tag: 'h3',
                getAttrs: function (dom) {
                    var textAlign = dom.style.textAlign;
                    var align = dom.getAttribute('align') || textAlign || null;
                    return {
                        level: 3,
                        align: align
                    };
                }
            },
            {
                tag: 'h4',
                getAttrs: function (dom) {
                    var textAlign = dom.style.textAlign;
                    var align = dom.getAttribute('align') || textAlign || null;
                    return {
                        level: 4,
                        align: align
                    };
                }
            },
            {
                tag: 'h5',
                getAttrs: function (dom) {
                    var textAlign = dom.style.textAlign;
                    var align = dom.getAttribute('align') || textAlign || null;
                    return {
                        level: 5,
                        align: align
                    };
                }
            },
            {
                tag: 'h6',
                getAttrs: function (dom) {
                    var textAlign = dom.style.textAlign;
                    var align = dom.getAttribute('align') || textAlign || null;
                    return {
                        level: 6,
                        align: align
                    };
                }
            },
        ],
        toDOM: function (node) {
            var _a = node.attrs, level = _a.level, align = _a.align;
            var styles = {
                textAlign: align !== 'left' ? align : null
            };
            var style = toStyleString(styles) || null;
            return ['h' + level, { style: style }, 0];
        }
    };
    // :: NodeSpec A code listing. Disallows marks or non-text inline
    // nodes by default. Represented as a `<pre>` element with a
    // `<code>` element inside of it.
    var codeBlock = {
        content: 'text*',
        marks: '',
        group: 'block',
        code: true,
        defining: true,
        parseDOM: [
            {
                tag: 'pre',
                preserveWhitespace: 'full'
            }
        ],
        toDOM: function () {
            return ['pre', ['code', 0]];
        }
    };
    // :: NodeSpec A hard line break, represented in the DOM as `<br>`.
    var hardBreak = {
        inline: true,
        group: 'inline',
        selectable: false,
        parseDOM: [{ tag: 'br' }],
        toDOM: function () {
            return ['br'];
        }
    };
    // :: NodeSpec An inline image (`<img>`) node. Supports `src`,
    // `alt`, and `href` attributes. The latter two default to the empty
    // string.
    var image = {
        inline: true,
        attrs: {
            src: {},
            alt: { default: null },
            title: { default: null },
            width: { default: null }
        },
        group: 'inline',
        draggable: true,
        parseDOM: [
            {
                tag: 'img[src]',
                getAttrs: function (dom) {
                    return {
                        src: dom.getAttribute('src'),
                        title: dom.getAttribute('title'),
                        alt: dom.getAttribute('alt'),
                        width: dom.getAttribute('width')
                    };
                }
            }
        ],
        toDOM: function (node) {
            var _a = node.attrs, src = _a.src, alt = _a.alt, title = _a.title, width = _a.width;
            return ['img', { src: src, alt: alt, title: title, width: width }];
        }
    };
    var listItem = Object.assign(Object.assign({}, sl.listItem), { content: 'paragraph block*' });
    var orderedList = Object.assign(Object.assign({}, sl.orderedList), { content: 'list_item+', group: 'block' });
    var bulletList = Object.assign(Object.assign({}, sl.bulletList), { content: 'list_item+', group: 'block' });
    var nodes = {
        doc: doc,
        text: text,
        paragraph: paragraph,
        blockquote: blockquote,
        horizontal_rule: horizontalRule,
        heading: heading,
        hard_break: hardBreak,
        code_block: codeBlock,
        image: image,
        list_item: listItem,
        ordered_list: orderedList,
        bullet_list: bulletList
    };

    // :: MarkSpec A link. Has `href` and `title` attributes. `title`
    // defaults to the empty string. Rendered and parsed as an `<a>`
    // element.
    var link = {
        attrs: {
            href: {},
            title: { default: null },
            target: { default: '_blank' }
        },
        inclusive: false,
        parseDOM: [
            {
                tag: 'a[href]',
                getAttrs: function (dom) {
                    return {
                        href: dom.getAttribute('href'),
                        title: dom.getAttribute('title'),
                        target: dom.getAttribute('target'),
                    };
                }
            }
        ],
        toDOM: function (node) {
            var _a = node.attrs, href = _a.href, title = _a.title, target = _a.target;
            return ['a', { href: href, title: title, target: target }, 0];
        }
    };
    // :: MarkSpec An emphasis mark. Rendered as an `<em>` element.
    // Has parse rules that also match `<i>` and `font-style: italic`.
    var em = {
        parseDOM: [
            { tag: 'i' },
            { tag: 'em' },
            { style: 'font-style=italic' }
        ],
        toDOM: function () {
            return ['em', 0];
        }
    };
    var ɵ0$1 = function (dom) {
        return dom.style.fontWeight !== 'normal' && null;
    }, ɵ1$1 = function (value) {
        return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null;
    };
    // :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules
    // also match `<b>` and `font-weight: bold`.
    var strong = {
        parseDOM: [
            { tag: 'strong' },
            // This works around a Google Docs misbehavior where
            // pasted content will be inexplicably wrapped in `<b>`
            // tags with a font-weight normal.
            {
                tag: 'b',
                getAttrs: ɵ0$1,
            },
            {
                style: 'font-weight',
                getAttrs: ɵ1$1
            }
        ],
        toDOM: function () {
            return ['strong', 0];
        }
    };
    // :: MarkSpec Code font mark. Represented as a `<code>` element.
    var code = {
        parseDOM: [
            { tag: 'code' }
        ],
        toDOM: function () {
            return ['code', 0];
        }
    };
    // :: MarkSpec An underline mark. Rendered as an `<u>` element.
    // Has parse rules that also match `text-decoration: underline`.
    var u = {
        parseDOM: [
            { tag: 'u' },
            { style: 'text-decoration=underline' }
        ],
        toDOM: function () {
            return ['u', 0];
        }
    };
    // :: MarkSpec An underline mark. Rendered as an `<s>` element.
    // Has parse rules that also match `strike`, `del` tag and css property `text-decoration: line-through`.
    var s = {
        parseDOM: [
            { tag: 's' },
            { tag: 'strike' },
            { style: 'text-decoration=line-through' }
        ],
        toDOM: function () {
            return ['s', 0];
        }
    };
    var ɵ2$1 = function (value) {
        return { color: value };
    };
    var textColor = {
        attrs: {
            color: {
                default: null
            },
        },
        parseDOM: [
            {
                style: 'color',
                getAttrs: ɵ2$1
            }
        ],
        toDOM: function (mark) {
            var color = mark.attrs.color;
            return ['span', { style: "color:" + color + ";" }, 0];
        },
    };
    var ɵ3 = function (value) {
        return { backgroundColor: value };
    };
    var textBackgroundColor = {
        attrs: {
            backgroundColor: {
                default: null
            },
        },
        parseDOM: [
            {
                style: 'background-color',
                getAttrs: ɵ3
            }
        ],
        toDOM: function (mark) {
            var backgroundColor = mark.attrs.backgroundColor;
            return ['span', { style: "background-color:" + backgroundColor + ";" }, 0];
        },
    };
    var makrs = {
        link: link,
        em: em,
        strong: strong,
        code: code,
        u: u,
        s: s,
        text_color: textColor,
        text_background_color: textBackgroundColor
    };

    var schema = new prosemirrorModel.Schema({
        marks: makrs,
        nodes: nodes
    });

    var DEFAULT_TOOLBAR = [
        ['bold', 'italic'],
        ['code', 'blockquote'],
        ['underline', 'strike'],
        ['ordered_list', 'bullet_list'],
        [{ heading: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }],
        ['link', 'image'],
        ['text_color', 'background_color'],
        ['align_left', 'align_center', 'align_right', 'align_justify'],
    ];
    var DEFAULT_COLOR_PRESETS = [
        '#b60205',
        '#d93f0b',
        '#fbca04',
        '#0e8a16',
        '#006b75',
        '#1d76db',
        '#0052cc',
        '#5319e7',
        '#e99695',
        '#f9d0c4',
        '#fef2c0',
        '#c2e0c6',
        '#bfdadc',
        '#c5def5',
        '#bfd4f2',
        '#d4c5f9'
    ];
    var DEFAULT_MENU = {
        toolbar: DEFAULT_TOOLBAR,
        colorPresets: []
    };
    var DEFAULT_SCHEMA = schema;
    var DEFAULT_PLUGINS = [];
    var NgxEditorServiceConfig = /** @class */ (function () {
        function NgxEditorServiceConfig() {
            this.plugins = DEFAULT_PLUGINS;
            this.nodeViews = {};
            this.schema = DEFAULT_SCHEMA;
            this.menu = DEFAULT_MENU;
            this.locals = {};
        }
        return NgxEditorServiceConfig;
    }());
    NgxEditorServiceConfig.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgxEditorServiceConfig_Factory() { return new NgxEditorServiceConfig(); }, token: NgxEditorServiceConfig, providedIn: "root" });
    NgxEditorServiceConfig.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    var NgxEditorService = /** @class */ (function () {
        function NgxEditorService(config) {
            this.config = config;
        }
        Object.defineProperty(NgxEditorService.prototype, "locals", {
            get: function () {
                return new Locals(this.config.locals);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxEditorService.prototype, "menu", {
            get: function () {
                return this.config.menu;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(NgxEditorService.prototype, "colorPresets", {
            get: function () {
                var col = 8;
                var colors = [];
                var colorPresets = this.config.menu.colorPresets;
                var allColors = colorPresets.length ? colorPresets : DEFAULT_COLOR_PRESETS;
                allColors.forEach(function (color, index) {
                    var row = Math.floor(index / col);
                    if (!colors[row]) {
                        colors.push([]);
                    }
                    colors[row].push(color);
                });
                return colors;
            },
            enumerable: false,
            configurable: true
        });
        return NgxEditorService;
    }());
    NgxEditorService.ɵprov = i0.ɵɵdefineInjectable({ factory: function NgxEditorService_Factory() { return new NgxEditorService(i0.ɵɵinject(NgxEditorServiceConfig, 8)); }, token: NgxEditorService, providedIn: "root" });
    NgxEditorService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    NgxEditorService.ctorParameters = function () { return [
        { type: NgxEditorServiceConfig, decorators: [{ type: i0.Optional }] }
    ]; };
    var provideMyServiceOptions = function (config) {
        var _a, _b, _c, _d;
        var menu;
        if (config.menu !== null) {
            if (!config.menu) {
                menu = DEFAULT_MENU;
            }
            else if (Array.isArray(config.menu)) {
                menu = Object.assign(Object.assign({}, DEFAULT_MENU), { toolbar: config.menu });
            }
            else {
                menu = Object.assign(Object.assign({}, DEFAULT_MENU), config.menu);
            }
        }
        return {
            plugins: (_a = config === null || config === void 0 ? void 0 : config.plugins) !== null && _a !== void 0 ? _a : DEFAULT_PLUGINS,
            nodeViews: (_b = config === null || config === void 0 ? void 0 : config.nodeViews) !== null && _b !== void 0 ? _b : {},
            menu: menu,
            schema: (_c = config === null || config === void 0 ? void 0 : config.schema) !== null && _c !== void 0 ? _c : DEFAULT_SCHEMA,
            locals: (_d = config.locals) !== null && _d !== void 0 ? _d : {}
        };
    };

    var _view;
    var SharedService = /** @class */ (function () {
        function SharedService() {
            _view.set(this, void 0);
            this.customMenuRefChange = new rxjs.Subject();
            this.plugin = {
                update: new rxjs.Subject(),
                destroy: new rxjs.Subject()
            };
        }
        Object.defineProperty(SharedService.prototype, "view", {
            get: function () {
                return __classPrivateFieldGet(this, _view);
            },
            set: function (v) {
                __classPrivateFieldSet(this, _view, v);
            },
            enumerable: false,
            configurable: true
        });
        SharedService.prototype.setCustomMenuRef = function (c) {
            this.customMenuRefChange.next(c);
        };
        return SharedService;
    }());
    _view = new WeakMap();
    SharedService.ɵprov = i0.ɵɵdefineInjectable({ factory: function SharedService_Factory() { return new SharedService(); }, token: SharedService, providedIn: "root" });
    SharedService.decorators = [
        { type: i0.Injectable, args: [{
                    providedIn: 'root'
                },] }
    ];
    SharedService.ctorParameters = function () { return []; };

    // https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment
    var toHTML = function (json, inputSchema) {
        var schema$1 = inputSchema !== null && inputSchema !== void 0 ? inputSchema : schema;
        var contentNode = schema$1.nodeFromJSON(json);
        var html = prosemirrorModel.DOMSerializer.fromSchema(schema$1).serializeFragment(contentNode.content);
        var div = document.createElement('div');
        div.appendChild(html);
        return div.innerHTML;
    };
    var toDoc = function (html, inputSchema) {
        var schema$1 = inputSchema !== null && inputSchema !== void 0 ? inputSchema : schema;
        var el = document.createElement('div');
        el.innerHTML = html;
        return prosemirrorModel.DOMParser.fromSchema(schema$1).parse(el).toJSON();
    };
    var parseValue = function (value, schema) {
        if (!value) {
            return null;
        }
        if (typeof value !== 'string') {
            return schema.nodeFromJSON(value);
        }
        var docJson = toDoc(value, schema);
        return schema.nodeFromJSON(docJson);
    };

    var NgxEditorComponent = /** @class */ (function () {
        function NgxEditorComponent(ngxEditorService, sharedService) {
            this.sharedService = sharedService;
            this.editorInitialized = false;
            this.placeholder = 'Type here...';
            this.editable = true;
            this.init = new i0.EventEmitter();
            this.focusOut = new i0.EventEmitter();
            this.focusIn = new i0.EventEmitter();
            this.config = ngxEditorService.config;
        }
        Object.defineProperty(NgxEditorComponent.prototype, "toolbar", {
            get: function () {
                var _a;
                return (_a = this.config.menu) === null || _a === void 0 ? void 0 : _a.toolbar;
            },
            enumerable: false,
            configurable: true
        });
        NgxEditorComponent.prototype.writeValue = function (value) {
            if (!this.editorInitialized) {
                return;
            }
            if (!this.outputFormat && typeof value === 'string') {
                this.outputFormat = 'html';
            }
            this.updateContent(value);
        };
        NgxEditorComponent.prototype.registerOnChange = function (fn) {
            this.onChange = fn;
        };
        NgxEditorComponent.prototype.registerOnTouched = function (fn) {
            this.onTouched = fn;
        };
        NgxEditorComponent.prototype.updateContent = function (value) {
            try {
                var state = this.view.state;
                var tr = state.tr, doc = state.doc;
                var newDoc = parseValue(value, this.config.schema);
                tr.replaceWith(0, state.doc.content.size, newDoc)
                    .setMeta('PREVENT_ONCHANGE', true);
                // don't emit if both content is same
                if (doc !== null && doc.eq(tr.doc)) {
                    return;
                }
                if (!tr.docChanged) {
                    return;
                }
                this.view.dispatch(tr);
            }
            catch (err) {
                console.error('Unable to update document.', err);
            }
        };
        NgxEditorComponent.prototype.handleTransactions = function (tr) {
            var state = this.view.state.applyTransaction(tr).state;
            this.view.updateState(state);
            if (!tr.docChanged || !this.onChange || tr.getMeta('PREVENT_ONCHANGE')) {
                return;
            }
            var json = state.doc.toJSON();
            if (this.outputFormat === 'html') {
                var html = toHTML(json, this.config.schema);
                this.onChange(html);
                return;
            }
            this.onChange(json);
        };
        NgxEditorComponent.prototype.createUpdateWatcherPlugin = function () {
            var _this = this;
            var plugin = new prosemirrorState.Plugin({
                key: new prosemirrorState.PluginKey('ngx-update-watcher'),
                view: function () {
                    return {
                        update: function (view) { return _this.sharedService.plugin.update.next(view); },
                        destroy: function () { return _this.sharedService.plugin.destroy.next(); }
                    };
                }
            });
            return plugin;
        };
        NgxEditorComponent.prototype.filterBuiltIns = function (plugin) {
            var pluginKey = plugin.key;
            if (/^(editable|placeholder)\$/.test(pluginKey)) {
                return false;
            }
            return true;
        };
        NgxEditorComponent.prototype.createEditor = function () {
            var _this = this;
            var _b = this.config, schema = _b.schema, plugins$1 = _b.plugins, nodeViews = _b.nodeViews;
            this.view = new prosemirrorView.EditorView(this.ngxEditor.nativeElement, {
                state: prosemirrorState.EditorState.create({
                    doc: null,
                    schema: schema,
                    plugins: __spread(plugins$1.filter(function (plugin) { return _this.filterBuiltIns(plugin); }), [
                        this.createUpdateWatcherPlugin(),
                        plugins.placeholder(this.placeholder),
                        plugins.editable(this.editable)
                    ])
                }),
                nodeViews: nodeViews,
                dispatchTransaction: this.handleTransactions.bind(this),
                handleDOMEvents: {
                    focus: function () {
                        _this.focusIn.emit();
                        return false;
                    },
                    blur: function () {
                        _this.onTouched();
                        _this.focusOut.emit();
                        return false;
                    }
                },
                attributes: {
                    class: 'NgxEditor__Content'
                },
            });
            this.editorInitialized = true;
            this.sharedService.view = this.view;
            this.sharedService.setCustomMenuRef(this.customMenuRef);
            this.init.emit(this.view);
        };
        NgxEditorComponent.prototype.setPlaceholder = function (newPlaceholder) {
            var _b = this.view, dispatch = _b.dispatch, tr = _b.state.tr;
            var placeholder = newPlaceholder !== null && newPlaceholder !== void 0 ? newPlaceholder : this.placeholder;
            dispatch(tr.setMeta('UPDATE_PLACEHOLDER', placeholder));
        };
        NgxEditorComponent.prototype.updateEditable = function (edit) {
            var _b = this.view, dispatch = _b.dispatch, tr = _b.state.tr;
            dispatch(tr.setMeta('UPDATE_EDITABLE', edit));
        };
        NgxEditorComponent.prototype.ngOnInit = function () {
            this.createEditor();
            this.setPlaceholder();
        };
        NgxEditorComponent.prototype.ngOnChanges = function (changes) {
            if ((changes === null || changes === void 0 ? void 0 : changes.placeholder) && !changes.placeholder.isFirstChange()) {
                this.setPlaceholder(changes.placeholder.currentValue);
            }
            if ((changes === null || changes === void 0 ? void 0 : changes.editable) && !changes.editable.isFirstChange()) {
                this.updateEditable(changes.editable.currentValue);
            }
        };
        NgxEditorComponent.prototype.ngOnDestroy = function () {
            this.view.destroy();
        };
        return NgxEditorComponent;
    }());
    NgxEditorComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ngx-editor',
                    template: "<div class=\"NgxEditor\" #ngxEditor>\n  <ngx-menu \n    [toolbar]=\"toolbar\" \n    [editorView]=\"view\"\n    *ngIf=\"toolbar\"\n    [disabled]=\"!editable\"\n  >\n  </ngx-menu>\n  <ngx-bubble></ngx-bubble>\n</div>\n",
                    providers: [{
                            provide: forms.NG_VALUE_ACCESSOR,
                            useExisting: i0.forwardRef(function () { return NgxEditorComponent; }),
                            multi: true
                        }],
                    encapsulation: i0.ViewEncapsulation.None,
                    styles: [".NgxEditor{background:#fff;background-clip:padding-box;border:2px solid rgba(0,0,0,.2);border-radius:4px;color:#000;overflow:hidden;position:relative}.NgxEditor--Disabled{opacity:.5;pointer-events:none}.NgxEditor__Placeholder{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;color:#6c757d;cursor:text;opacity:1;position:absolute;user-select:none}.NgxEditor__Content{padding:.5rem;white-space:pre-wrap}.NgxEditor__Content p{margin:0 0 .7rem}.NgxEditor__Content blockquote{border-left:3px solid #ddd;margin-left:0;margin-right:0;padding-left:1rem}.NgxEditor__Content--Disabled{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;pointer-events:none;user-select:none}.NgxEditor__ImageWrapper{display:inline-block;line-height:0;padding:2px;position:relative}.NgxEditor__ImageWrapper.NgxEditor__Resizer--Active{border:1px solid #1a73e8;padding:1px}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle{display:none;height:100%;position:absolute;width:100%}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BL,.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BR,.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TL,.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TR{background-color:#1a73e8;border:1px solid #fff;height:7px;position:absolute;width:7px}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BR{bottom:-5px;cursor:se-resize;right:-5px}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TR{cursor:ne-resize;right:-5px;top:-5px}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TL{cursor:nw-resize;left:-5px;top:-5px}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BL{bottom:-5px;cursor:sw-resize;left:-5px}.ProseMirror{outline:none}.NgxEditor__HelpText{font-size:80%}.NgxEditor__HelpText.NgxEditor__HelpText--Error{color:red}"]
                },] }
    ];
    NgxEditorComponent.ctorParameters = function () { return [
        { type: NgxEditorService },
        { type: SharedService }
    ]; };
    NgxEditorComponent.propDecorators = {
        ngxEditor: [{ type: i0.ViewChild, args: ['ngxEditor', { static: true },] }],
        outputFormat: [{ type: i0.Input }],
        customMenuRef: [{ type: i0.Input }],
        placeholder: [{ type: i0.Input }],
        editable: [{ type: i0.Input }],
        init: [{ type: i0.Output }],
        focusOut: [{ type: i0.Output }],
        focusIn: [{ type: i0.Output }]
    };

    var MenuComponent = /** @class */ (function () {
        function MenuComponent(sharedService) {
            var _this = this;
            this.sharedService = sharedService;
            this.disabled = false;
            this.customMenuRef = null;
            this.simpleCommands = [
                'bold', 'italic',
                'underline', 'strike',
                'code', 'blockquote',
                'ordered_list', 'bullet_list',
                'align_left', 'align_center', 'align_right', 'align_justify'
            ];
            this.iconContainerClass = ['NgxEditor__MenuItem', 'NgxEditor__MenuItem--Icon'];
            this.dropdownContainerClass = ['NgxEditor__Dropdown'];
            this.seperatorClass = ['NgxEditor__Seperator'];
            this.customMenuRefSubscription = this.sharedService.customMenuRefChange.subscribe(function (ref) {
                _this.customMenuRef = ref;
            });
        }
        MenuComponent.prototype.isDropDown = function (item) {
            if (typeof item === 'object') {
                return true;
            }
            return false;
        };
        MenuComponent.prototype.ngOnDestroy = function () {
            this.customMenuRefSubscription.unsubscribe();
        };
        return MenuComponent;
    }());
    MenuComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ngx-menu',
                    template: "<div class=\"NgxEditor__MenuBar\" [ngClass]=\"{'NgxEditor--Disabled': disabled}\">\n\n  <ng-container *ngFor=\"let toolbarItem of toolbar; let lastToolbarItem = last\">\n    <ng-container *ngFor=\"let item of toolbarItem; let lastItem = last\">\n\n      <!-- simple icons -->\n      <ngx-simple-command [name]=\"item\" [class]=\"iconContainerClass\" *ngIf=\"simpleCommands.includes(item)\">\n      </ngx-simple-command>\n\n      <!-- link -->\n      <ngx-link [name]=\"item\" [class]=\"iconContainerClass\" *ngIf=\"item === 'link'\">\n      </ngx-link>\n\n      <!-- image -->\n      <ngx-image [name]=\"item\" [class]=\"iconContainerClass\" *ngIf=\"item === 'image'\">\n      </ngx-image>\n\n      <!-- dropdown -->\n      <ng-container *ngIf=\"isDropDown(item)\">\n        <ng-container *ngFor=\"let dropdown of item | keyvalue\">\n          <ngx-dropdown [class]=\"dropdownContainerClass\" [group]=\"dropdown.key\" [items]=\"dropdown.value\">\n          </ngx-dropdown>\n        </ng-container>\n      </ng-container>\n\n      <!-- text color picker -->\n      <ngx-color-picker [class]=\"iconContainerClass\" *ngIf=\"item === 'text_color'\" type=\"text_color\">\n      </ngx-color-picker>\n      <!-- background color picker -->\n      <ngx-color-picker [class]=\"iconContainerClass\" *ngIf=\"item === 'background_color'\" type=\"background_color\">\n      </ngx-color-picker>\n\n      <!-- seperator -->\n      <div [class]=\"seperatorClass\" *ngIf=\"lastItem && !lastToolbarItem\"></div>\n    </ng-container>\n  </ng-container>\n\n  <!-- custom menu -->\n  <ng-container *ngIf=\"customMenuRef\">\n    <ng-container [ngTemplateOutlet]=\"customMenuRef\"></ng-container>\n  </ng-container>\n\n</div>\n",
                    encapsulation: i0.ViewEncapsulation.None,
                    styles: [".NgxEditor__MenuBar{border-bottom:1px solid #ddd;cursor:default;display:flex;height:1.85rem;padding:.2rem}.NgxEditor__MenuItem{align-items:center;border-radius:2px;display:flex;flex-shrink:0;justify-content:center;position:relative}.NgxEditor__MenuItem:hover{background-color:#f1f1f1}.NgxEditor__MenuItem.NgxEditor__MenuItem--Icon{height:1.85rem;transition:.3s ease-in-out;width:1.85rem}.NgxEditor__MenuItem.NgxEditor__MenuItem--Icon+.NgxEditor__MenuItem--Icon{margin-left:2px}.NgxEditor__MenuItem .NgxEditor__MenuItem--IconContainer{align-items:center;display:flex;height:100%;justify-content:center;width:100%}.NgxEditor__MenuItem.NgxEditor__MenuItem--Text{padding:0 .3rem}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active{background-color:#e8f0fe}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active.NgxEditor__MenuItem--Text{color:#1a73e8}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active svg{fill:#1a73e8}.NgxEditor__Dropdown{align-items:center;display:flex;flex-shrink:0;min-width:4rem;position:relative}.NgxEditor__Dropdown:hover{background-color:#f1f1f1}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text{align-items:center;display:flex;height:100%;justify-content:center;padding:0 .3rem;width:100%}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text:after{border-bottom:0;border-left:.25rem solid transparent;border-right:.25rem solid transparent;border-top:.25rem solid;content:\"\";display:inline-block;margin-left:1.5rem;vertical-align:.25rem}.NgxEditor__Dropdown .NgxEditor__Dropdown--DropdownMenu{background-color:#fff;border-radius:4px;box-shadow:0 2px 6px 2px rgba(60,64,67,.15);left:0;position:absolute;top:calc(1.85rem + 2px);width:100%;z-index:10}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item{color:inherit;padding:.5rem;white-space:nowrap}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item:hover{background-color:#ececec}.NgxEditor__Dropdown.NgxEditor__Dropdown--Open,.NgxEditor__Dropdown.NgxEditor__Dropdown--Selected{background-color:#e8f0fe}.NgxEditor__Dropdown.NgxEditor__Dropdown--Open .NgxEditor__Dropdown--Text,.NgxEditor__Dropdown.NgxEditor__Dropdown--Selected .NgxEditor__Dropdown--Text{color:#1a73e8}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active{background-color:#f1f1f1}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active:hover{background-color:#e7e7e7}.NgxEditor__Popup{background-color:#fff;border-radius:4px;box-shadow:0 2px 6px 2px rgba(60,64,67,.15);min-width:12rem;padding:8px;position:absolute;top:calc(1.85rem + 2px);z-index:10}.NgxEditor__Popup .NgxEditor__Popup--FormGroup{margin-bottom:8px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup label{margin-bottom:3px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup input[type=text],.NgxEditor__Popup .NgxEditor__Popup--FormGroup input[type=url]{padding:2px 4px}.NgxEditor__Popup .NgxEditor__Popup--Col{display:flex;flex-direction:column;position:relative}.NgxEditor__Popup .NgxEditor__Popup--Label{font-size:85%}.NgxEditor__Seperator{border-left:1px solid #ccc;margin:0 .3rem}"]
                },] }
    ];
    MenuComponent.ctorParameters = function () { return [
        { type: SharedService }
    ]; };
    MenuComponent.propDecorators = {
        toolbar: [{ type: i0.Input }],
        editorView: [{ type: i0.Input }],
        disabled: [{ type: i0.Input }]
    };

    var MarkToggle = /** @class */ (function () {
        function MarkToggle(name) {
            this.name = name;
        }
        MarkToggle.prototype.execute = function (state, dispatch) {
            var schema = state.schema;
            var type = schema.marks[this.name];
            if (!type) {
                return false;
            }
            return prosemirrorCommands.toggleMark(type)(state, dispatch);
        };
        MarkToggle.prototype.isActive = function (state) {
            var schema = state.schema;
            var type = schema.marks[this.name];
            if (!type) {
                return false;
            }
            return helpers.isMarkActive(state, type);
        };
        MarkToggle.prototype.canExecute = function (state) {
            return this.execute(state, null);
        };
        return MarkToggle;
    }());

    var BlockqoteToggle = /** @class */ (function () {
        function BlockqoteToggle() {
        }
        BlockqoteToggle.prototype.execute = function (state, dispatch) {
            var schema = state.schema;
            var type = schema.nodes.blockquote;
            if (!type) {
                return false;
            }
            if (this.isActive(state)) {
                return prosemirrorCommands.lift(state, dispatch);
            }
            return prosemirrorCommands.wrapIn(type)(state, dispatch);
        };
        BlockqoteToggle.prototype.isActive = function (state) {
            var schema = state.schema;
            var type = schema.nodes.blockquote;
            if (!type) {
                return false;
            }
            return helpers.isNodeActive(state, type);
        };
        BlockqoteToggle.prototype.canExecute = function (state) {
            return this.execute(state, null);
        };
        return BlockqoteToggle;
    }());

    var ListItemToggle = /** @class */ (function () {
        function ListItemToggle(isBulletList) {
            if (isBulletList === void 0) { isBulletList = false; }
            this.isBulletList = false;
            this.isBulletList = isBulletList;
        }
        ListItemToggle.prototype.getType = function (schema) {
            return this.isBulletList ? schema.nodes.bullet_list : schema.nodes.ordered_list;
        };
        ListItemToggle.prototype.execute = function (state, dispatch) {
            var schema = state.schema;
            var type = this.getType(schema);
            if (!type) {
                return false;
            }
            if (this.isActive(state)) {
                return sl.liftListItem(schema.nodes.list_item)(state, dispatch);
            }
            return sl.wrapInList(type)(state, dispatch);
        };
        ListItemToggle.prototype.isActive = function (state) {
            var schema = state.schema;
            var type = this.getType(schema);
            if (!type) {
                return false;
            }
            return helpers.isNodeActive(state, type);
        };
        ListItemToggle.prototype.canExecute = function (state) {
            return this.execute(state, null);
        };
        return ListItemToggle;
    }());

    var Heading = /** @class */ (function () {
        function Heading(level) {
            this.level = level;
        }
        Heading.prototype.execute = function (state, dispatch) {
            var _a;
            var schema = state.schema, selection = state.selection, doc = state.doc;
            var type = schema.nodes.heading;
            if (!type) {
                return false;
            }
            var nodePos = selection.$from.before(1);
            var node = doc.nodeAt(nodePos);
            var attrs = (_a = node === null || node === void 0 ? void 0 : node.attrs) !== null && _a !== void 0 ? _a : {};
            if (this.isActive(state)) {
                return prosemirrorCommands.setBlockType(schema.nodes.paragraph, attrs)(state, dispatch);
            }
            return prosemirrorCommands.setBlockType(type, Object.assign(Object.assign({}, attrs), { level: this.level }))(state, dispatch);
        };
        Heading.prototype.isActive = function (state) {
            var _this = this;
            var schema = state.schema;
            var nodesInSelection = helpers.getSelectionNodes(state);
            var type = schema.nodes.heading;
            if (!type) {
                return false;
            }
            var supportedNodes = [
                type,
                schema.nodes.text,
                schema.nodes.blockquote
            ];
            // heading is a text node
            // don't mark as active when it has more nodes
            var nodes = nodesInSelection.filter(function (node) {
                return supportedNodes.includes(node.type);
            });
            var acitveNode = nodes.find(function (node) {
                return node.attrs.level === _this.level;
            });
            return Boolean(acitveNode);
        };
        Heading.prototype.canExecute = function (state) {
            return this.execute(state, null);
        };
        return Heading;
    }());

    var TextAlign = /** @class */ (function () {
        function TextAlign(align) {
            this.align = align;
        }
        TextAlign.prototype.execute = function (state, dispatch) {
            var _this = this;
            var doc = state.doc, selection = state.selection, tr = state.tr, schema = state.schema;
            var from = selection.from, to = selection.to;
            var applicable = false;
            doc.nodesBetween(from, to, function (node, pos) {
                var nodeType = node.type;
                if ([schema.nodes.paragraph, schema.nodes.heading].includes(nodeType)) {
                    applicable = true;
                    tr.setNodeMarkup(pos, nodeType, Object.assign(Object.assign({}, node.attrs), { align: _this.align }));
                }
                return true;
            });
            if (!applicable) {
                return false;
            }
            if (tr.docChanged) {
                dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr);
            }
            return true;
        };
        TextAlign.prototype.isActive = function (state) {
            var _this = this;
            var nodes = helpers.getSelectionNodes(state);
            var active = nodes.find(function (node) {
                return node.attrs.align === _this.align;
            });
            return Boolean(active);
        };
        TextAlign.prototype.canExecute = function (state) {
            return this.execute(state, null);
        };
        return TextAlign;
    }());

    var defaultOptions = {
        strict: true
    };
    var Link = /** @class */ (function () {
        function Link() {
        }
        Link.prototype.update = function (attrs, state, dispatch) {
            if (attrs === void 0) { attrs = {}; }
            var schema = state.schema;
            var type = schema.marks.link;
            if (!type) {
                return false;
            }
            return prosemirrorCommands.toggleMark(type, attrs)(state, dispatch);
        };
        Link.prototype.insert = function (text, attrs, state, dispatch) {
            if (attrs === void 0) { attrs = {}; }
            var schema = state.schema, tr = state.tr;
            var type = schema.marks.link;
            if (!type) {
                return false;
            }
            var node = schema.text(text, [schema.marks.link.create(attrs)]);
            dispatch(tr.replaceSelectionWith(node, false));
            return true;
        };
        Link.prototype.isActive = function (state, options) {
            if (options === void 0) { options = defaultOptions; }
            if (options.strict) {
                return true;
            }
            var schema = state.schema;
            return helpers.isMarkActive(state, schema.marks.link);
        };
        Link.prototype.remove = function (state, dispatch) {
            return commands.removeLink()(state, dispatch);
        };
        Link.prototype.canExecute = function (state) {
            return this.update({}, state, null);
        };
        return Link;
    }());

    var Image = /** @class */ (function () {
        function Image() {
        }
        Image.prototype.execute = function (attrs, state, dispatch) {
            if (attrs === void 0) { attrs = {}; }
            var schema = state.schema, tr = state.tr, selection = state.selection;
            var type = schema.nodes.image;
            if (!type) {
                return false;
            }
            var nodeAttrs = Object.assign(Object.assign({}, attrs), { width: null });
            if (selection instanceof prosemirrorState.NodeSelection && selection.node.type === type) {
                nodeAttrs.width = selection.node.attrs.width;
            }
            tr.replaceSelectionWith(type.createAndFill(nodeAttrs));
            if (tr.docChanged) {
                dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr);
                return true;
            }
            return false;
        };
        Image.prototype.isActive = function (state) {
            var selection = state.selection;
            if (selection instanceof prosemirrorState.NodeSelection) {
                return selection.node.type.name === 'image';
            }
            return false;
        };
        return Image;
    }());

    var TextColor = /** @class */ (function () {
        function TextColor(name) {
            this.name = name;
        }
        TextColor.prototype.execute = function (attrs) {
            var _this = this;
            return function (state, dispatch) {
                var schema = state.schema, selection = state.selection, doc = state.doc;
                var type = schema.marks[_this.name];
                if (!type) {
                    return false;
                }
                var from = selection.from, to = selection.to, empty = selection.empty;
                if (!empty && (from + 1 === to)) {
                    var node = doc.nodeAt(from);
                    if (node.isAtom && !node.isText && node.isLeaf) {
                        // An atomic node (e.g. Image) is selected.
                        return false;
                    }
                }
                return commands.applyMark(type, attrs)(state, dispatch);
            };
        };
        TextColor.prototype.isActive = function (state) {
            var schema = state.schema;
            var type = schema.marks[this.name];
            if (!type) {
                return false;
            }
            return helpers.isMarkActive(state, type);
        };
        TextColor.prototype.getActiveColors = function (state) {
            var _this = this;
            if (!this.isActive(state)) {
                return [];
            }
            var schema = state.schema;
            var marks = helpers.getSelectionMarks(state);
            var colors = marks
                .filter(function (mark) { return mark.type === schema.marks[_this.name]; })
                .map(function (mark) { return mark.attrs.color; })
                .filter(Boolean);
            return colors;
        };
        TextColor.prototype.remove = function (state, dispatch) {
            var tr = state.tr;
            var selection = state.selection, schema = state.schema;
            var empty = selection.empty, from = selection.from, to = selection.to;
            var type = schema.marks[this.name];
            if (!type) {
                return false;
            }
            if (empty) {
                tr.removeStoredMark(type);
            }
            else {
                tr.removeMark(from, to, type);
                if (!tr.docChanged) {
                    return false;
                }
            }
            dispatch(tr.scrollIntoView());
            return true;
        };
        TextColor.prototype.canExecute = function (state) {
            return this.execute({})(state, null);
        };
        return TextColor;
    }());

    var STRONG = new MarkToggle('strong');
    var EM = new MarkToggle('em');
    var CODE = new MarkToggle('code');
    var UNDERLINE = new MarkToggle('u');
    var STRIKE = new MarkToggle('s');
    var BLOCKQUOTE = new BlockqoteToggle();
    var UL = new ListItemToggle(true);
    var OL = new ListItemToggle(false);
    var H1 = new Heading(1);
    var H2 = new Heading(2);
    var H3 = new Heading(3);
    var H4 = new Heading(4);
    var H5 = new Heading(5);
    var H6 = new Heading(6);
    var ALIGN_LEFT = new TextAlign('left');
    var ALIGN_CENTER = new TextAlign('center');
    var ALIGN_RIGHT = new TextAlign('right');
    var ALIGN_JUSTIFY = new TextAlign('justify');
    var LINK = new Link();
    var IMAGE = new Image();
    var TEXT_COLOR = new TextColor('text_color');
    var TEXT_BACKGROUND_COLOR = new TextColor('text_background_color');

    var SimpleCommands = new Map();
    SimpleCommands.set('bold', STRONG);
    SimpleCommands.set('italic', EM);
    SimpleCommands.set('code', CODE);
    SimpleCommands.set('underline', UNDERLINE);
    SimpleCommands.set('strike', STRIKE);
    SimpleCommands.set('blockquote', BLOCKQUOTE);
    SimpleCommands.set('bullet_list', UL);
    SimpleCommands.set('ordered_list', OL);
    SimpleCommands.set('h1', H1);
    SimpleCommands.set('h2', H2);
    SimpleCommands.set('h3', H3);
    SimpleCommands.set('h4', H4);
    SimpleCommands.set('h5', H5);
    SimpleCommands.set('h6', H6);
    SimpleCommands.set('align_left', ALIGN_LEFT);
    SimpleCommands.set('align_center', ALIGN_CENTER);
    SimpleCommands.set('align_right', ALIGN_RIGHT);
    SimpleCommands.set('align_justify', ALIGN_JUSTIFY);
    var Link$1 = LINK;
    var Image$1 = IMAGE;
    var TextColor$1 = TEXT_COLOR;
    var TextBackgroundColor = TEXT_BACKGROUND_COLOR;

    /* tslint:disable */
    var bold = "\n  <path d=\"M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z\" />\n  <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n";

    var italic = "\n  <path d=\"M0 0h24v24H0z\" fill=\"none\" />\n  <path d=\"M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z\" />\n";

    var code$1 = "\n<path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n<path d=\"M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z\"/>\n";

    var underline = "\n<path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n<path d=\"M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z\"/>\n";

    var strike = "\n<path d=\"M6.85,7.08C6.85,4.37,9.45,3,12.24,3c1.64,0,3,0.49,3.9,1.28c0.77,0.65,1.46,1.73,1.46,3.24h-3.01 c0-0.31-0.05-0.59-0.15-0.85c-0.29-0.86-1.2-1.28-2.25-1.28c-1.86,0-2.34,1.02-2.34,1.7c0,0.48,0.25,0.88,0.74,1.21 C10.97,8.55,11.36,8.78,12,9H7.39C7.18,8.66,6.85,8.11,6.85,7.08z M21,12v-2H3v2h9.62c1.15,0.45,1.96,0.75,1.96,1.97 c0,1-0.81,1.67-2.28,1.67c-1.54,0-2.93-0.54-2.93-2.51H6.4c0,0.55,0.08,1.13,0.24,1.58c0.81,2.29,3.29,3.3,5.67,3.3 c2.27,0,5.3-0.89,5.3-4.05c0-0.3-0.01-1.16-0.48-1.94H21V12z\"/>\n";

    var orderedList$1 = "\n<path d=\"M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z\"/>\n<path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n";

    var bulletList$1 = "\n<path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n<path d=\"M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z\"/>\n";

    var quote = "\n<path d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z\"/>\n";

    var link$1 = "\n<path d=\"M0 0h24v24H0z\" fill=\"none\"/><path d=\"M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z\"/>\n";

    var unlink = "\n<path d=\"M0 0h24v24H0V0z\" fill=\"none\"/>\n<path d=\"M17 7h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.43-.98 2.63-2.31 2.98l1.46 1.46C20.88 15.61 22 13.95 22 12c0-2.76-2.24-5-5-5zm-1 4h-2.19l2 2H16zM2 4.27l3.11 3.11C3.29 8.12 2 9.91 2 12c0 2.76 2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1 0-1.59 1.21-2.9 2.76-3.07L8.73 11H8v2h2.73L13 15.27V17h1.73l4.01 4L20 19.74 3.27 3 2 4.27z\"/>\n<path d=\"M0 24V0\" fill=\"none\"/>\n";

    var image$1 = "\n<path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n<path d=\"M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z\"/>\n";

    var alignLeft = "\n<path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n<path d=\"M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z\"/>\n";

    var alignCenter = "\n<path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n<path d=\"M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z\"/>\n";

    var alignRight = "\n<path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n<path d=\"M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z\"/>\n";

    var alignJustify = "\n<path d=\"M0 0h24v24H0z\" fill=\"none\"/>\n<path d=\"M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z\"/>\n";

    var textColor$1 = "\n<path d=\"M2,20h20v4H2V20z M5.49,17h2.42l1.27-3.58h5.65L16.09,17h2.42L13.25,3h-2.5L5.49,17z M9.91,11.39l2.03-5.79h0.12l2.03,5.79 H9.91z\"/>\n";

    var colorFill = "\n<path d=\"M16.56,8.94L7.62,0L6.21,1.41l2.38,2.38L3.44,8.94c-0.59,0.59-0.59,1.54,0,2.12l5.5,5.5C9.23,16.85,9.62,17,10,17 s0.77-0.15,1.06-0.44l5.5-5.5C17.15,10.48,17.15,9.53,16.56,8.94z M5.21,10L10,5.21L14.79,10H5.21z M19,11.5c0,0-2,2.17-2,3.5 c0,1.1,0.9,2,2,2s2-0.9,2-2C21,13.67,19,11.5,19,11.5z M2,20h20v4H2V20z\"/>\n";

    // Icons source: https://material.io/
    var DEFAULT_ICON_HEIGHT = 20;
    var DEFAULT_ICON_WIDTH = 20;
    var icons = {
        bold: bold,
        italic: italic,
        code: code$1,
        underline: underline,
        strike: strike,
        ordered_list: orderedList$1,
        bullet_list: bulletList$1,
        blockquote: quote,
        link: link$1,
        unlink: unlink,
        image: image$1,
        align_left: alignLeft,
        align_center: alignCenter,
        align_right: alignRight,
        align_justify: alignJustify,
        text_color: textColor$1,
        color_fill: colorFill
    };
    var Icon = /** @class */ (function () {
        function Icon() {
        }
        Icon.get = function (name) {
            var path = icons[name] || '<path></path>';
            return "\n      <svg\n        xmlns=\"http://www.w3.org/2000/svg\"\n        viewBox=\"0 0 24 24\"\n        fill=\"black\"\n        height=" + DEFAULT_ICON_HEIGHT + "\n        width=" + DEFAULT_ICON_WIDTH + "\n      >\n        " + path + "\n      </svg>\n    ";
        };
        return Icon;
    }());

    var SimpleCommandComponent = /** @class */ (function () {
        function SimpleCommandComponent(ngxeService, sharedService) {
            var _this = this;
            this.ngxeService = ngxeService;
            this.sharedService = sharedService;
            this.isActive = false;
            this.disabled = false;
            this.update = function (view) {
                var state = view.state;
                var command = SimpleCommands.get(_this.name);
                _this.isActive = command.isActive(state);
                _this.disabled = !command.canExecute(state);
            };
            this.editorView = this.sharedService.view;
            this.pluginUpdateSubscription = this.sharedService.plugin.update.subscribe(function (view) {
                _this.update(view);
            });
        }
        SimpleCommandComponent.prototype.toggle = function (e) {
            e.preventDefault();
            if (e.button !== 0) {
                return;
            }
            var _a = this.editorView, state = _a.state, dispatch = _a.dispatch;
            var command = SimpleCommands.get(this.name);
            command.execute(state, dispatch);
        };
        SimpleCommandComponent.prototype.getTitle = function (name) {
            return this.ngxeService.locals.get(name);
        };
        SimpleCommandComponent.prototype.ngOnInit = function () {
            this.html = Icon.get(this.name);
        };
        SimpleCommandComponent.prototype.ngOnDestroy = function () {
            this.pluginUpdateSubscription.unsubscribe();
        };
        return SimpleCommandComponent;
    }());
    SimpleCommandComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ngx-simple-command',
                    template: "<div class=\"NgxEditor__MenuItem--IconContainer\" [innerHTML]=\"html | sanitizeHtml\" (mousedown)=\"toggle($event)\"\n  [title]=\"getTitle(name)\">\n</div>\n",
                    styles: [""]
                },] }
    ];
    SimpleCommandComponent.ctorParameters = function () { return [
        { type: NgxEditorService },
        { type: SharedService }
    ]; };
    SimpleCommandComponent.propDecorators = {
        name: [{ type: i0.Input }],
        isActive: [{ type: i0.HostBinding, args: ['class.NgxEditor__MenuItem--Active',] }],
        disabled: [{ type: i0.HostBinding, args: ['class.NgxEditor--Disabled',] }]
    };

    var LinkComponent = /** @class */ (function () {
        function LinkComponent(el, ngxeService, sharedService) {
            var _this = this;
            this.el = el;
            this.ngxeService = ngxeService;
            this.sharedService = sharedService;
            this.showPopup = false;
            this.isActive = false;
            this.canExecute = true;
            this.form = new forms.FormGroup({
                href: new forms.FormControl('', [
                    forms.Validators.required,
                    forms.Validators.pattern('(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?')
                ]),
                text: new forms.FormControl('', [forms.Validators.required]),
                openInNewTab: new forms.FormControl(true)
            });
            this.setText = function () {
                var _a = _this.editorView.state, selection = _a.selection, doc = _a.doc;
                var empty = selection.empty, from = selection.from, to = selection.to;
                var selectedText = !empty ? doc.textBetween(from, to) : '';
                if (selectedText) {
                    _this.text.patchValue(selectedText);
                    _this.text.disable();
                }
            };
            this.update = function (view) {
                var state = view.state;
                _this.isActive = Link$1.isActive(state, { strict: false });
                _this.canExecute = Link$1.canExecute(state);
            };
            this.editorView = this.sharedService.view;
            this.pluginUpdateSubscription = this.sharedService.plugin.update.subscribe(function (view) {
                _this.update(view);
            });
        }
        Object.defineProperty(LinkComponent.prototype, "valid", {
            get: function () {
                return this.isActive || this.showPopup;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LinkComponent.prototype, "disabled", {
            get: function () {
                return !this.canExecute;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LinkComponent.prototype, "icon", {
            get: function () {
                return Icon.get(this.isActive ? 'unlink' : 'link');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LinkComponent.prototype, "href", {
            get: function () {
                return this.form.get('href');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(LinkComponent.prototype, "text", {
            get: function () {
                return this.form.get('text');
            },
            enumerable: false,
            configurable: true
        });
        LinkComponent.prototype.onDocumentClick = function (e) {
            if (!this.el.nativeElement.contains(e.target) && this.showPopup) {
                this.hideForm();
            }
        };
        LinkComponent.prototype.getLabel = function (key) {
            return this.ngxeService.locals.get(key);
        };
        LinkComponent.prototype.hideForm = function () {
            this.showPopup = false;
            this.form.reset({
                href: '',
                text: '',
                openInNewTab: true
            });
            this.text.enable();
        };
        LinkComponent.prototype.onMouseDown = function (e) {
            e.preventDefault();
            if (e.button !== 0) {
                return;
            }
            var _a = this.editorView, state = _a.state, dispatch = _a.dispatch;
            if (this.isActive) {
                Link$1.remove(state, dispatch);
                return;
            }
            this.showPopup = !this.showPopup;
            if (this.showPopup) {
                this.setText();
            }
        };
        LinkComponent.prototype.insertLink = function (e) {
            e.preventDefault();
            var _a = this.form.getRawValue(), text = _a.text, href = _a.href, openInNewTab = _a.openInNewTab;
            var _b = this.editorView, dispatch = _b.dispatch, state = _b.state;
            var selection = state.selection;
            var attrs = {
                title: href,
                href: href,
                target: openInNewTab ? '_blank' : '_self'
            };
            if (selection.empty) {
                Link$1.insert(text, attrs, state, dispatch);
            }
            else {
                Link$1.update(attrs, state, dispatch);
            }
            this.hideForm();
        };
        LinkComponent.prototype.ngOnDestroy = function () {
            this.pluginUpdateSubscription.unsubscribe();
        };
        return LinkComponent;
    }());
    LinkComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ngx-link',
                    template: "<div class=\"NgxEditor__MenuItem--IconContainer\" [innerHTML]=\"icon | sanitizeHtml\" (mousedown)=\"onMouseDown($event)\">\n</div>\n\n<!-- popup -->\n<div *ngIf=\"showPopup\" class=\"NgxEditor__Popup\">\n  <form class=\"NgxEditor__Popup--Form\" [formGroup]=\"form\" (ngSubmit)=\"insertLink($event)\">\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\">{{getLabel('url')}}</label>\n        <input type=\"href\" id=\"href\" formControlName=\"href\" autofocus autocomplete=\"off\" />\n        <div *ngIf=\"href.touched && href.invalid\" class=\"NgxEditor__HelpText NgxEditor__HelpText--Error\">\n          {{ href.errors.pattern && 'Please enter valid url.' }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\">{{getLabel('text')}}</label>\n        <input type=\"text\" formControlName=\"text\" autocomplete=\"off\" />\n        <div *ngIf=\"text.touched && text.invalid\" class=\"NgxEditor__HelpText NgxEditor__HelpText--Error\">\n          {{ text.errors.required && 'This is required' }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label>\n          <input type=\"checkbox\" formControlName=\"openInNewTab\" />\n          {{getLabel('openInNewTab')}}\n        </label>\n      </div>\n    </div>\n\n    <button type=\"submit\" [disabled]=\"!form.valid\">{{getLabel('insert')}}</button>\n\n  </form>\n</div>\n",
                    styles: [""]
                },] }
    ];
    LinkComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: NgxEditorService },
        { type: SharedService }
    ]; };
    LinkComponent.propDecorators = {
        name: [{ type: i0.Input }],
        valid: [{ type: i0.HostBinding, args: ['class.NgxEditor__MenuItem--Active',] }],
        disabled: [{ type: i0.HostBinding, args: ['class.NgxEditor--Disabled',] }],
        onDocumentClick: [{ type: i0.HostListener, args: ['document:mousedown', ['$event'],] }]
    };

    var DropdownComponent = /** @class */ (function () {
        function DropdownComponent(ngxeService, sharedService, el) {
            var _this = this;
            this.ngxeService = ngxeService;
            this.sharedService = sharedService;
            this.el = el;
            this.isDropdownOpen = false;
            this.activeItems = [];
            this.disabledItems = [];
            this.update = function (view) {
                var state = view.state;
                _this.activeItems = [];
                _this.disabledItems = [];
                _this.items.forEach(function (item) {
                    var command = SimpleCommands.get(item);
                    var isActive = command.isActive(state);
                    if (isActive) {
                        _this.activeItems.push(item);
                    }
                    if (!command.canExecute(state)) {
                        _this.disabledItems.push(item);
                    }
                });
                if (_this.activeItems.length === 1) {
                    _this.activeItem = _this.activeItems[0];
                }
                else {
                    _this.activeItem = null;
                }
            };
            this.editorView = this.sharedService.view;
            this.pluginUpdateSubscription = this.sharedService.plugin.update.subscribe(function (view) {
                _this.update(view);
            });
        }
        Object.defineProperty(DropdownComponent.prototype, "isSelected", {
            get: function () {
                return Boolean(this.activeItem || this.isDropdownOpen);
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(DropdownComponent.prototype, "isDropdownDisabled", {
            get: function () {
                return this.disabledItems.length === this.items.length;
            },
            enumerable: false,
            configurable: true
        });
        DropdownComponent.prototype.onDocumentClick = function (target) {
            if (!this.el.nativeElement.contains(target) && this.isDropdownOpen) {
                this.isDropdownOpen = false;
            }
        };
        DropdownComponent.prototype.getName = function (key) {
            return this.ngxeService.locals.get(key);
        };
        DropdownComponent.prototype.toggleDropdown = function (e) {
            e.preventDefault();
            this.isDropdownOpen = !this.isDropdownOpen;
        };
        DropdownComponent.prototype.onClick = function (e, item) {
            e.preventDefault();
            // consider only left click
            if (e.button !== 0) {
                return;
            }
            var command = SimpleCommands.get(item);
            var _a = this.editorView, state = _a.state, dispatch = _a.dispatch;
            command.execute(state, dispatch);
            this.isDropdownOpen = false;
        };
        DropdownComponent.prototype.ngOnInit = function () {
            this.selected = this.group;
        };
        DropdownComponent.prototype.ngOnDestroy = function () {
            this.pluginUpdateSubscription.unsubscribe();
        };
        return DropdownComponent;
    }());
    DropdownComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ngx-dropdown',
                    template: "<div class=\"NgxEditor__Dropdown--Text\" (mousedown)=\"toggleDropdown($event)\">\n  {{getName(activeItem || selected)}}\n</div>\n\n<div class=\"NgxEditor__Dropdown--DropdownMenu\" *ngIf=\"isDropdownOpen\">\n  <div class=\"NgxEditor__Dropdown--Item\" *ngFor=\"let item of items\" (mousedown)=\"onClick($event, item)\"\n    [ngClass]=\"{'NgxEditor__Dropdown--Active': item === activeItem, 'NgxEditor--Disabled':disabledItems.includes(item)}\">\n    {{getName(item)}}\n  </div>\n</div>\n",
                    styles: [""]
                },] }
    ];
    DropdownComponent.ctorParameters = function () { return [
        { type: NgxEditorService },
        { type: SharedService },
        { type: i0.ElementRef }
    ]; };
    DropdownComponent.propDecorators = {
        group: [{ type: i0.Input }],
        items: [{ type: i0.Input }],
        isSelected: [{ type: i0.HostBinding, args: ['class.NgxEditor__Dropdown--Selected',] }],
        isDropdownDisabled: [{ type: i0.HostBinding, args: ['class.NgxEditor--Disabled',] }],
        onDocumentClick: [{ type: i0.HostListener, args: ['document:mousedown', ['$event.target'],] }]
    };

    var ImageComponent = /** @class */ (function () {
        function ImageComponent(el, ngxeService, sharedService) {
            var _this = this;
            this.el = el;
            this.ngxeService = ngxeService;
            this.sharedService = sharedService;
            this.showPopup = false;
            this.isActive = false;
            this.form = new forms.FormGroup({
                src: new forms.FormControl('', [
                    forms.Validators.required,
                    forms.Validators.pattern('(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?')
                ]),
                alt: new forms.FormControl(''),
                title: new forms.FormControl('')
            });
            this.update = function (view) {
                var state = view.state;
                _this.isActive = Image$1.isActive(state);
            };
            this.editorView = this.sharedService.view;
            this.pluginUpdateSubscription = this.sharedService.plugin.update.subscribe(function (view) {
                _this.update(view);
            });
        }
        Object.defineProperty(ImageComponent.prototype, "valid", {
            get: function () {
                return this.isActive || this.showPopup;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ImageComponent.prototype, "icon", {
            get: function () {
                return Icon.get('image');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ImageComponent.prototype, "src", {
            get: function () {
                return this.form.get('src');
            },
            enumerable: false,
            configurable: true
        });
        ImageComponent.prototype.onDocumentClick = function (e) {
            if (!this.el.nativeElement.contains(e.target) && this.showPopup) {
                this.hideForm();
            }
        };
        ImageComponent.prototype.getLabel = function (key) {
            return this.ngxeService.locals.get(key);
        };
        ImageComponent.prototype.hideForm = function () {
            this.showPopup = false;
            this.form.reset({
                src: '',
                alt: '',
                title: ''
            });
        };
        ImageComponent.prototype.onMouseDown = function (e) {
            e.preventDefault();
            if (e.button !== 0) {
                return;
            }
            this.showPopup = !this.showPopup;
            if (this.showPopup) {
                this.fillForm();
            }
        };
        ImageComponent.prototype.fillForm = function () {
            var state = this.editorView.state;
            var selection = state.selection;
            if (selection instanceof prosemirrorState.NodeSelection && this.isActive) {
                var _a = selection.node.attrs, src = _a.src, _b = _a.alt, alt = _b === void 0 ? '' : _b, _c = _a.title, title = _c === void 0 ? '' : _c;
                this.form.setValue({
                    src: src,
                    alt: alt,
                    title: title
                });
            }
        };
        ImageComponent.prototype.insertLink = function (e) {
            e.preventDefault();
            var _a = this.form.getRawValue(), src = _a.src, alt = _a.alt, title = _a.title;
            var _b = this.editorView, dispatch = _b.dispatch, state = _b.state;
            var attrs = {
                src: src,
                alt: alt,
                title: title
            };
            Image$1.execute(attrs, state, dispatch);
            this.hideForm();
        };
        ImageComponent.prototype.ngOnDestroy = function () {
            this.pluginUpdateSubscription.unsubscribe();
        };
        return ImageComponent;
    }());
    ImageComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ngx-image',
                    template: "<div class=\"NgxEditor__MenuItem--IconContainer\" [innerHTML]=\"icon | sanitizeHtml\" (mousedown)=\"onMouseDown($event)\">\n</div>\n\n<!-- popup -->\n<div *ngIf=\"showPopup\" class=\"NgxEditor__Popup\">\n  <form class=\"NgxEditor__Popup--Form\" [formGroup]=\"form\" (ngSubmit)=\"insertLink($event)\">\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\">{{getLabel('url')}}</label>\n        <input type=\"href\" id=\"href\" formControlName=\"src\" autofocus autocomplete=\"off\" />\n        <div *ngIf=\"src.touched && src.invalid\" class=\"NgxEditor__HelpText NgxEditor__HelpText--Error\">\n          {{ src.errors.pattern && 'Please enter valid url.' }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\">{{getLabel('altText')}}</label>\n        <input type=\"text\" formControlName=\"alt\" autocomplete=\"off\" />\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\">{{getLabel('title')}}</label>\n        <input type=\"text\" formControlName=\"title\" autocomplete=\"off\" />\n      </div>\n    </div>\n\n    <button type=\"submit\" [disabled]=\"!form.valid || !form.dirty\">{{getLabel('insert')}}</button>\n\n  </form>\n</div>\n",
                    styles: [""]
                },] }
    ];
    ImageComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: NgxEditorService },
        { type: SharedService }
    ]; };
    ImageComponent.propDecorators = {
        name: [{ type: i0.Input }],
        valid: [{ type: i0.HostBinding, args: ['class.NgxEditor__MenuItem--Active',] }],
        onDocumentClick: [{ type: i0.HostListener, args: ['document:mousedown', ['$event'],] }]
    };

    var ColorPickerComponent = /** @class */ (function () {
        function ColorPickerComponent(el, sharedService, ngxeService) {
            var _this = this;
            this.el = el;
            this.sharedService = sharedService;
            this.ngxeService = ngxeService;
            this.showPopup = false;
            this.isActive = false;
            this.activeColors = [];
            this.canExecute = true;
            this.update = function (view) {
                var state = view.state;
                _this.canExecute = _this.command.execute(null)(state);
                _this.isActive = _this.command.isActive(state);
                _this.activeColors = [];
                if (_this.isActive) {
                    _this.activeColors = _this.command.getActiveColors(state);
                }
            };
            this.editorView = this.sharedService.view;
            this.pluginUpdateSubscription = this.sharedService.plugin.update.subscribe(function (view) {
                _this.update(view);
            });
        }
        Object.defineProperty(ColorPickerComponent.prototype, "valid", {
            get: function () {
                return this.isActive || this.showPopup;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "disabled", {
            get: function () {
                return !this.canExecute;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "presets", {
            get: function () {
                return this.ngxeService.colorPresets;
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "title", {
            get: function () {
                return this.getLabel(this.type === 'text_color' ? 'text_color' : 'background_color');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "icon", {
            get: function () {
                return Icon.get(this.type === 'text_color' ? 'text_color' : 'color_fill');
            },
            enumerable: false,
            configurable: true
        });
        Object.defineProperty(ColorPickerComponent.prototype, "command", {
            get: function () {
                return this.type === 'text_color' ? TextColor$1 : TextBackgroundColor;
            },
            enumerable: false,
            configurable: true
        });
        ColorPickerComponent.prototype.getContrastYIQ = function (hexcolor) {
            hexcolor = hexcolor.replace('#', '');
            var r = parseInt(hexcolor.substr(0, 2), 16);
            var g = parseInt(hexcolor.substr(2, 2), 16);
            var b = parseInt(hexcolor.substr(4, 2), 16);
            var yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
            return (yiq >= 128) ? 'black' : 'white';
        };
        ColorPickerComponent.prototype.onDocumentClick = function (e) {
            if (!this.el.nativeElement.contains(e.target) && this.showPopup) {
                this.hidePopup();
            }
        };
        ColorPickerComponent.prototype.hidePopup = function () {
            this.showPopup = false;
        };
        ColorPickerComponent.prototype.togglePopup = function (e) {
            e.preventDefault();
            if (e.button !== 0) {
                return;
            }
            this.showPopup = !this.showPopup;
        };
        ColorPickerComponent.prototype.remove = function (e) {
            e.preventDefault();
            var _a = this.editorView, state = _a.state, dispatch = _a.dispatch;
            this.command.remove(state, dispatch);
            this.hidePopup();
        };
        ColorPickerComponent.prototype.onColorSelect = function (e, color) {
            e.preventDefault();
            if (e.button !== 0) {
                return;
            }
            var _a = this.editorView, state = _a.state, dispatch = _a.dispatch;
            var attrs = {};
            if (this.type === 'text_color') {
                attrs.color = color;
            }
            else {
                attrs.backgroundColor = color;
            }
            this.command.execute(attrs)(state, dispatch);
            if (!this.editorView.hasFocus()) {
                this.editorView.focus();
            }
            this.hidePopup();
        };
        ColorPickerComponent.prototype.getLabel = function (key) {
            return this.ngxeService.locals.get(key);
        };
        ColorPickerComponent.prototype.ngOnDestroy = function () {
            this.pluginUpdateSubscription.unsubscribe();
        };
        return ColorPickerComponent;
    }());
    ColorPickerComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ngx-color-picker',
                    template: "<div class=\"NgxEditor__MenuItem--IconContainer\" [innerHTML]=\"icon | sanitizeHtml\" (mousedown)=\"togglePopup($event)\"\n  [title]=\"title\">\n</div>\n\n<div *ngIf=\"showPopup\" class=\"NgxEditor__Popup\">\n  <div *ngFor=\"let colorGroup of presets\" class=\"NgxEditor__ColorContainer\">\n    <button class=\"NgxEditor__Color\" *ngFor=\"let color of colorGroup\"\n      [ngStyle]=\"{backgroundColor: color, color:getContrastYIQ(color)}\" [title]=\"color\"\n      (mousedown)=\"onColorSelect($event, color)\"\n      [ngClass]=\"{'NgxEditor__Color--Active': activeColors.includes(color)}\"></button>\n  </div>\n\n  <button class=\"NgxEditor__MenuItem--Button\" (mousedown)=\"remove($event)\" [disabled]=\"!isActive\">\n    {{getLabel('remove')}}\n  </button>\n</div>\n",
                    styles: ["@charset \"UTF-8\";.NgxEditor__Popup{width:230px}.NgxEditor__ColorContainer{display:flex;justify-content:space-between}.NgxEditor__ColorContainer+.NgxEditor__ColorContainer{margin-top:5px}.NgxEditor__Color{border:none;border-radius:6px;flex-shrink:0;height:24px;outline:none;width:24px}.NgxEditor__Color--Active:after{content:\"\u2714\";font-size:90%}.NgxEditor__MenuItem--Button{margin-top:5px}"]
                },] }
    ];
    ColorPickerComponent.ctorParameters = function () { return [
        { type: i0.ElementRef },
        { type: SharedService },
        { type: NgxEditorService }
    ]; };
    ColorPickerComponent.propDecorators = {
        valid: [{ type: i0.HostBinding, args: ['class.NgxEditor__MenuItem--Active',] }],
        disabled: [{ type: i0.HostBinding, args: ['class.NgxEditor--Disabled',] }],
        type: [{ type: i0.Input }],
        onDocumentClick: [{ type: i0.HostListener, args: ['document:mousedown', ['$event'],] }]
    };

    var SanitizeHtmlPipe = /** @class */ (function () {
        function SanitizeHtmlPipe(sanitizer) {
            this.sanitizer = sanitizer;
        }
        SanitizeHtmlPipe.prototype.transform = function (value) {
            return this.sanitizer.bypassSecurityTrustHtml(value);
        };
        return SanitizeHtmlPipe;
    }());
    SanitizeHtmlPipe.decorators = [
        { type: i0.Pipe, args: [{
                    name: 'sanitizeHtml'
                },] }
    ];
    SanitizeHtmlPipe.ctorParameters = function () { return [
        { type: platformBrowser.DomSanitizer }
    ]; };

    var MenuModule = /** @class */ (function () {
        function MenuModule() {
        }
        return MenuModule;
    }());
    MenuModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        forms.ReactiveFormsModule
                    ],
                    declarations: [
                        // pipes
                        SanitizeHtmlPipe,
                        // components
                        MenuComponent,
                        SimpleCommandComponent,
                        LinkComponent,
                        DropdownComponent,
                        ImageComponent,
                        ColorPickerComponent
                    ],
                    exports: [MenuComponent],
                },] }
    ];

    var BubbleComponent = /** @class */ (function () {
        function BubbleComponent(sharedService, el, renderer) {
            var _this = this;
            this.sharedService = sharedService;
            this.el = el;
            this.renderer = renderer;
            this.pluginUpdateSubscription = this.sharedService.plugin.update.subscribe(function (view) {
                _this.view = view;
                _this.update(view);
            });
        }
        BubbleComponent.prototype.setDomPosition = function (view) {
            // Otherwise, reposition it and update its content
            this.showBubble();
            var _a = helpers.calculateBubblePos(view, this.el.nativeElement), bottom = _a.bottom, left = _a.left;
            this.renderer.setStyle(this.el.nativeElement, 'left', left + "px");
            this.renderer.setStyle(this.el.nativeElement, 'bottom', bottom + "px");
        };
        BubbleComponent.prototype.showBubble = function () {
            this.renderer.setStyle(this.el.nativeElement, 'display', '');
        };
        BubbleComponent.prototype.hideBubble = function () {
            this.renderer.setStyle(this.el.nativeElement, 'display', 'none');
        };
        BubbleComponent.prototype.removeLink = function () {
            var _a = this.view, state = _a.state, dispatch = _a.dispatch;
            commands.removeLink()(state, dispatch);
            this.view.focus();
        };
        BubbleComponent.prototype.update = function (view) {
            var state = view.state;
            var schema = state.schema, selection = state.selection;
            if (!schema.marks.link) {
                return;
            }
            if (selection instanceof prosemirrorState.NodeSelection) {
                if (selection.node.type.name === 'image') {
                    return;
                }
            }
            var hasFocus = view.hasFocus();
            var isActive = helpers.isLinkActive(state);
            var linkMarks = helpers.getSelectionMarks(state).filter(function (mark) { return mark.type === schema.marks.link; });
            // hide for selection and show only for clicks
            if (!hasFocus || !isActive) {
                this.hideBubble();
                return;
            }
            var _a = __read(linkMarks, 1), linkItem = _a[0];
            this.activeLinkItem = linkItem;
            // update dom position
            this.setDomPosition(view);
        };
        BubbleComponent.prototype.ngOnInit = function () {
        };
        BubbleComponent.prototype.ngOnDestroy = function () {
            this.pluginUpdateSubscription.unsubscribe();
        };
        return BubbleComponent;
    }());
    BubbleComponent.decorators = [
        { type: i0.Component, args: [{
                    selector: 'ngx-bubble',
                    template: "<ng-container *ngIf=\"activeLinkItem\">\n  <a [href]=\"activeLinkItem.attrs.href\" target=\"_blank\" [title]=\"activeLinkItem.attrs.href\">\n    {{activeLinkItem.attrs.href}}\n  </a>\n  <div class=\"commands\">\n    <button class=\"command\" (click)=\"removeLink()\">Remove link</button>\n  </div>\n</ng-container>\n",
                    styles: [":host{align-items:center;background:#fff;border:1px solid silver;border-radius:4px;display:flex;margin-bottom:.3rem;padding:.3rem;position:absolute;transform:translateX(-50%);z-index:20}:host:after,:host:before{border:solid transparent;border-width:5px 5px 0;content:\"\";height:0;left:50%;margin-left:-5px;position:absolute;width:0}:host:before{border-top-color:silver;bottom:-6px}:host:after{border-top-color:#fff;bottom:-4.5px}:host a{display:inline-block;margin-left:2px;max-width:15rem;overflow:hidden;text-overflow:ellipsis}:host .commands{display:flex;margin-left:.5rem}:host .commands .command{background-color:#f1f1f1;border:none;border-radius:2px;display:flex;padding:2px;white-space:nowrap}:host .commands .command:hover{text-decoration:underline}"]
                },] }
    ];
    BubbleComponent.ctorParameters = function () { return [
        { type: SharedService },
        { type: i0.ElementRef },
        { type: i0.Renderer2 }
    ]; };

    var NGX_EDITOR_CONFIG_TOKEN = new i0.InjectionToken('NgxEditorConfig');
    var NgxEditorModule = /** @class */ (function () {
        function NgxEditorModule() {
        }
        NgxEditorModule.forRoot = function (config) {
            return {
                ngModule: NgxEditorModule,
                providers: [
                    {
                        provide: NGX_EDITOR_CONFIG_TOKEN,
                        useValue: config
                    },
                    {
                        provide: NgxEditorServiceConfig,
                        useFactory: provideMyServiceOptions,
                        deps: [NGX_EDITOR_CONFIG_TOKEN]
                    }
                ]
            };
        };
        return NgxEditorModule;
    }());
    NgxEditorModule.decorators = [
        { type: i0.NgModule, args: [{
                    imports: [
                        common.CommonModule,
                        MenuModule,
                    ],
                    providers: [
                        SharedService
                    ],
                    declarations: [
                        NgxEditorComponent,
                        BubbleComponent
                    ],
                    exports: [NgxEditorComponent],
                    entryComponents: [BubbleComponent]
                },] }
    ];

    function isEmptyInputValue(value) {
        // we don't check for string here so it also works with arrays
        return value == null || value.length === 0;
    }
    function hasValidLength(value) {
        // non-strict comparison is intentional, to check for both `null` and `undefined` values
        return value != null && typeof value.length === 'number';
    }
    // @dynamic
    var Validators = /** @class */ (function () {
        function Validators() {
        }
        Validators.required = function (userSchema) {
            return function (control) {
                var _a;
                var schema$1 = userSchema || schema;
                var doc = parseValue(control.value, schema$1);
                var isEmpty = doc.childCount === 1
                    && ((_a = doc === null || doc === void 0 ? void 0 : doc.firstChild) === null || _a === void 0 ? void 0 : _a.isTextblock)
                    && doc.firstChild.content.size === 0;
                if (!isEmpty) {
                    return null;
                }
                return {
                    required: true
                };
            };
        };
        Validators.maxLength = function (maxLength, userSchema) {
            return function (control) {
                var schema$1 = userSchema || schema;
                var doc = parseValue(control.value, schema$1);
                var value = doc.textContent;
                if (hasValidLength(value) && value.length > maxLength) {
                    return {
                        maxlength: {
                            requiredLength: maxLength,
                            actualLength: value.length
                        }
                    };
                }
                return null;
            };
        };
        Validators.minLength = function (minLength, userSchema) {
            return function (control) {
                var schema$1 = userSchema || schema;
                var doc = parseValue(control.value, schema$1);
                var value = doc.textContent;
                if (isEmptyInputValue(value) || !hasValidLength(value)) {
                    // don't validate empty values to allow optional controls
                    // don't validate values without `length` property
                    return null;
                }
                if (value.length < minLength) {
                    return {
                        minlength: {
                            requiredLength: minLength, actualLength: value.length
                        }
                    };
                }
                return null;
            };
        };
        return Validators;
    }());

    /**
     * Generated bundle index. Do not edit.
     */

    exports.NgxEditorComponent = NgxEditorComponent;
    exports.NgxEditorModule = NgxEditorModule;
    exports.Validators = Validators;
    exports.marks = makrs;
    exports.nodes = nodes;
    exports.parseValue = parseValue;
    exports.schema = schema;
    exports.toDoc = toDoc;
    exports.toHTML = toHTML;
    exports.ɵa = NgxEditorServiceConfig;
    exports.ɵb = NgxEditorService;
    exports.ɵc = provideMyServiceOptions;
    exports.ɵd = SharedService;
    exports.ɵe = MenuModule;
    exports.ɵf = SanitizeHtmlPipe;
    exports.ɵg = MenuComponent;
    exports.ɵh = SimpleCommandComponent;
    exports.ɵi = LinkComponent;
    exports.ɵj = DropdownComponent;
    exports.ɵk = ImageComponent;
    exports.ɵl = ColorPickerComponent;
    exports.ɵm = BubbleComponent;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=ngx-editor.umd.js.map
