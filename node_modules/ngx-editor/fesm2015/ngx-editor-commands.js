import { TextSelection } from 'prosemirror-state';

const removeLink = () => {
    return (state, dispatch) => {
        const { doc, selection, tr } = state;
        const { $head: { pos }, from, to } = selection;
        // if the cursor is on the link without any selection
        if (from === to) {
            const $pos = doc.resolve(pos);
            const linkStart = pos - $pos.textOffset;
            const linkEnd = linkStart + $pos.parent.child($pos.index()).nodeSize;
            tr.removeMark(linkStart, linkEnd);
        }
        else {
            tr.removeMark(from, to);
        }
        if (!tr.docChanged) {
            return false;
        }
        dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr);
        return true;
    };
};

// Ref: https://github.com/ProseMirror/prosemirror-commands/blob/master/src/commands.js
function markApplies(doc, ranges, type) {
    for (const range of ranges) {
        const { $from, $to } = range;
        let canApply = $from.depth === 0 ? doc.type.allowsMarkType(type) : false;
        doc.nodesBetween($from.pos, $to.pos, (node) => {
            if (canApply) {
                return false;
            }
            canApply = node.inlineContent && node.type.allowsMarkType(type);
            return true;
        });
        if (canApply) {
            return true;
        }
    }
    return false;
}
const applyMark = (type, attrs = {}) => {
    return (state, dispatch) => {
        const { tr, selection } = state;
        const { $from, $to, empty, ranges } = selection;
        if (empty && selection instanceof TextSelection) {
            const { $cursor } = selection;
            if (!$cursor || !markApplies(state.doc, ranges, type)) {
                return false;
            }
            tr.addStoredMark(type.create(attrs));
            dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr);
        }
        else {
            tr.addMark($from.pos, $to.pos, type.create(attrs));
            if (!tr.docChanged) {
                return false;
            }
            dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr.scrollIntoView());
        }
        return true;
    };
};

/**
 * Generated bundle index. Do not edit.
 */

export { applyMark, removeLink };
//# sourceMappingURL=ngx-editor-commands.js.map
