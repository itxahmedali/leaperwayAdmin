import { ɵɵdefineInjectable, Injectable, ɵɵinject, Optional, EventEmitter, Component, forwardRef, ViewEncapsulation, ViewChild, Input, Output, HostBinding, ElementRef, HostListener, Pipe, NgModule, Renderer2, InjectionToken } from '@angular/core';
import { NG_VALUE_ACCESSOR, FormGroup, FormControl, Validators as Validators$1, ReactiveFormsModule } from '@angular/forms';
import { Plugin, PluginKey, EditorState, NodeSelection } from 'prosemirror-state';
import { EditorView } from 'prosemirror-view';
import { Schema, DOMSerializer, DOMParser } from 'prosemirror-model';
import { listItem as listItem$1, orderedList as orderedList$2, bulletList as bulletList$2, liftListItem, wrapInList } from 'prosemirror-schema-list';
import { __classPrivateFieldSet, __classPrivateFieldGet } from 'tslib';
import { Subject } from 'rxjs';
import { placeholder, editable } from 'ngx-editor/plugins';
import { CommonModule } from '@angular/common';
import { toggleMark, lift, wrapIn, setBlockType } from 'prosemirror-commands';
import { isMarkActive, isNodeActive, getSelectionNodes, getSelectionMarks, calculateBubblePos, isLinkActive } from 'ngx-editor/helpers';
import { removeLink, applyMark } from 'ngx-editor/commands';
import { DomSanitizer } from '@angular/platform-browser';

const defaults = {
    // menu
    bold: 'Bold',
    italic: 'Italic',
    code: 'Code',
    underline: 'Underline',
    strike: 'Strike',
    blockquote: 'Blockquote',
    bullet_list: 'Bullet List',
    ordered_list: 'Ordered List',
    heading: 'Heading',
    h1: 'Header 1',
    h2: 'Header 2',
    h3: 'Header 3',
    h4: 'Header 4',
    h5: 'Header 5',
    h6: 'Header 6',
    align_left: 'Left Align',
    align_center: 'Center Align',
    align_right: 'Right Align',
    align_justify: 'Justify',
    text_color: 'Text Color',
    background_color: 'Background Color',
    // pupups, forms, others...
    url: 'URL',
    text: 'Text',
    openInNewTab: 'Open in new tab',
    insert: 'Insert',
    altText: 'Alt Text',
    title: 'Title',
    remove: 'Remove',
};
class Locals {
    constructor(newLocals = {}) {
        this.locals = defaults;
        this.get = (key) => {
            var _a;
            return (_a = this.locals[key]) !== null && _a !== void 0 ? _a : '';
        };
        this.locals = Object.assign({}, defaults, newLocals);
    }
}

const camelToDashed = (str) => {
    return str.replace(/[A-Z]/g, m => '-' + m.toLowerCase());
};
const ɵ0 = camelToDashed;
const cleanObject = (obj) => {
    const cleanObj = {};
    Object.keys(obj).forEach((prop) => {
        if (obj[prop]) {
            cleanObj[prop] = obj[prop];
        }
    });
    return cleanObj;
};
const ɵ1 = cleanObject;
const toStyleString = (obj) => {
    const styles = cleanObject(obj);
    return Object.entries(styles).map(([k, v]) => `${camelToDashed(k)}:${v}`).join(';');
};
const ɵ2 = toStyleString;

const doc = {
    content: 'block+'
};
// :: NodeSpec The text node.
const text = {
    group: 'inline'
};
// :: NodeSpec A plain paragraph textblock. Represented in the DOM
// as a `<p>` element.
const paragraph = {
    content: 'inline*',
    group: 'block',
    attrs: {
        align: {
            default: null,
        }
    },
    parseDOM: [
        {
            tag: 'p',
            getAttrs(dom) {
                const { textAlign } = dom.style;
                const align = dom.getAttribute('align') || textAlign || null;
                return {
                    align
                };
            }
        }
    ],
    toDOM(node) {
        const { align } = node.attrs;
        const styles = {
            textAlign: align !== 'left' ? align : null
        };
        const style = toStyleString(styles) || null;
        return ['p', { style }, 0];
    }
};
// :: NodeSpec A blockquote (`<blockquote>`) wrapping one or more blocks.
const blockquote = {
    content: 'block+',
    group: 'block',
    defining: true,
    parseDOM: [{ tag: 'blockquote' }],
    toDOM() {
        return ['blockquote', 0];
    }
};
// :: NodeSpec A horizontal rule (`<hr>`).
const horizontalRule = {
    group: 'block',
    parseDOM: [{ tag: 'hr' }],
    toDOM() {
        return ['hr'];
    }
};
// :: NodeSpec A heading textblock, with a `level` attribute that
// should hold the number 1 to 6. Parsed and serialized as `<h1>` to
// `<h6>` elements.
const heading = {
    attrs: {
        level: {
            default: 1
        },
        align: {
            default: null,
        }
    },
    content: 'inline*',
    group: 'block',
    defining: true,
    parseDOM: [
        {
            tag: 'h1',
            getAttrs(dom) {
                const { textAlign } = dom.style;
                const align = dom.getAttribute('align') || textAlign || null;
                return {
                    level: 1,
                    align
                };
            }
        },
        {
            tag: 'h2',
            getAttrs(dom) {
                const { textAlign } = dom.style;
                const align = dom.getAttribute('align') || textAlign || null;
                return {
                    level: 2,
                    align
                };
            }
        },
        {
            tag: 'h3',
            getAttrs(dom) {
                const { textAlign } = dom.style;
                const align = dom.getAttribute('align') || textAlign || null;
                return {
                    level: 3,
                    align
                };
            }
        },
        {
            tag: 'h4',
            getAttrs(dom) {
                const { textAlign } = dom.style;
                const align = dom.getAttribute('align') || textAlign || null;
                return {
                    level: 4,
                    align
                };
            }
        },
        {
            tag: 'h5',
            getAttrs(dom) {
                const { textAlign } = dom.style;
                const align = dom.getAttribute('align') || textAlign || null;
                return {
                    level: 5,
                    align
                };
            }
        },
        {
            tag: 'h6',
            getAttrs(dom) {
                const { textAlign } = dom.style;
                const align = dom.getAttribute('align') || textAlign || null;
                return {
                    level: 6,
                    align
                };
            }
        },
    ],
    toDOM(node) {
        const { level, align } = node.attrs;
        const styles = {
            textAlign: align !== 'left' ? align : null
        };
        const style = toStyleString(styles) || null;
        return ['h' + level, { style }, 0];
    }
};
// :: NodeSpec A code listing. Disallows marks or non-text inline
// nodes by default. Represented as a `<pre>` element with a
// `<code>` element inside of it.
const codeBlock = {
    content: 'text*',
    marks: '',
    group: 'block',
    code: true,
    defining: true,
    parseDOM: [
        {
            tag: 'pre',
            preserveWhitespace: 'full'
        }
    ],
    toDOM() {
        return ['pre', ['code', 0]];
    }
};
// :: NodeSpec A hard line break, represented in the DOM as `<br>`.
const hardBreak = {
    inline: true,
    group: 'inline',
    selectable: false,
    parseDOM: [{ tag: 'br' }],
    toDOM() {
        return ['br'];
    }
};
// :: NodeSpec An inline image (`<img>`) node. Supports `src`,
// `alt`, and `href` attributes. The latter two default to the empty
// string.
const image = {
    inline: true,
    attrs: {
        src: {},
        alt: { default: null },
        title: { default: null },
        width: { default: null }
    },
    group: 'inline',
    draggable: true,
    parseDOM: [
        {
            tag: 'img[src]',
            getAttrs(dom) {
                return {
                    src: dom.getAttribute('src'),
                    title: dom.getAttribute('title'),
                    alt: dom.getAttribute('alt'),
                    width: dom.getAttribute('width')
                };
            }
        }
    ],
    toDOM(node) {
        const { src, alt, title, width } = node.attrs;
        return ['img', { src, alt, title, width }];
    }
};
const listItem = Object.assign(Object.assign({}, listItem$1), { content: 'paragraph block*' });
const orderedList = Object.assign(Object.assign({}, orderedList$2), { content: 'list_item+', group: 'block' });
const bulletList = Object.assign(Object.assign({}, bulletList$2), { content: 'list_item+', group: 'block' });
const nodes = {
    doc,
    text,
    paragraph,
    blockquote,
    horizontal_rule: horizontalRule,
    heading,
    hard_break: hardBreak,
    code_block: codeBlock,
    image,
    list_item: listItem,
    ordered_list: orderedList,
    bullet_list: bulletList
};

// :: MarkSpec A link. Has `href` and `title` attributes. `title`
// defaults to the empty string. Rendered and parsed as an `<a>`
// element.
const link = {
    attrs: {
        href: {},
        title: { default: null },
        target: { default: '_blank' }
    },
    inclusive: false,
    parseDOM: [
        {
            tag: 'a[href]',
            getAttrs(dom) {
                return {
                    href: dom.getAttribute('href'),
                    title: dom.getAttribute('title'),
                    target: dom.getAttribute('target'),
                };
            }
        }
    ],
    toDOM(node) {
        const { href, title, target } = node.attrs;
        return ['a', { href, title, target }, 0];
    }
};
// :: MarkSpec An emphasis mark. Rendered as an `<em>` element.
// Has parse rules that also match `<i>` and `font-style: italic`.
const em = {
    parseDOM: [
        { tag: 'i' },
        { tag: 'em' },
        { style: 'font-style=italic' }
    ],
    toDOM() {
        return ['em', 0];
    }
};
const ɵ0$1 = (dom) => {
    return dom.style.fontWeight !== 'normal' && null;
}, ɵ1$1 = (value) => {
    return /^(bold(er)?|[5-9]\d{2,})$/.test(value) && null;
};
// :: MarkSpec A strong mark. Rendered as `<strong>`, parse rules
// also match `<b>` and `font-weight: bold`.
const strong = {
    parseDOM: [
        { tag: 'strong' },
        // This works around a Google Docs misbehavior where
        // pasted content will be inexplicably wrapped in `<b>`
        // tags with a font-weight normal.
        {
            tag: 'b',
            getAttrs: ɵ0$1,
        },
        {
            style: 'font-weight',
            getAttrs: ɵ1$1
        }
    ],
    toDOM() {
        return ['strong', 0];
    }
};
// :: MarkSpec Code font mark. Represented as a `<code>` element.
const code = {
    parseDOM: [
        { tag: 'code' }
    ],
    toDOM() {
        return ['code', 0];
    }
};
// :: MarkSpec An underline mark. Rendered as an `<u>` element.
// Has parse rules that also match `text-decoration: underline`.
const u = {
    parseDOM: [
        { tag: 'u' },
        { style: 'text-decoration=underline' }
    ],
    toDOM() {
        return ['u', 0];
    }
};
// :: MarkSpec An underline mark. Rendered as an `<s>` element.
// Has parse rules that also match `strike`, `del` tag and css property `text-decoration: line-through`.
const s = {
    parseDOM: [
        { tag: 's' },
        { tag: 'strike' },
        { style: 'text-decoration=line-through' }
    ],
    toDOM() {
        return ['s', 0];
    }
};
const ɵ2$1 = (value) => {
    return { color: value };
};
const textColor = {
    attrs: {
        color: {
            default: null
        },
    },
    parseDOM: [
        {
            style: 'color',
            getAttrs: ɵ2$1
        }
    ],
    toDOM(mark) {
        const { color } = mark.attrs;
        return ['span', { style: `color:${color};` }, 0];
    },
};
const ɵ3 = (value) => {
    return { backgroundColor: value };
};
const textBackgroundColor = {
    attrs: {
        backgroundColor: {
            default: null
        },
    },
    parseDOM: [
        {
            style: 'background-color',
            getAttrs: ɵ3
        }
    ],
    toDOM(mark) {
        const { backgroundColor } = mark.attrs;
        return ['span', { style: `background-color:${backgroundColor};` }, 0];
    },
};
const makrs = {
    link,
    em,
    strong,
    code,
    u,
    s,
    text_color: textColor,
    text_background_color: textBackgroundColor
};

const schema = new Schema({
    marks: makrs,
    nodes
});

const DEFAULT_TOOLBAR = [
    ['bold', 'italic'],
    ['code', 'blockquote'],
    ['underline', 'strike'],
    ['ordered_list', 'bullet_list'],
    [{ heading: ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'] }],
    ['link', 'image'],
    ['text_color', 'background_color'],
    ['align_left', 'align_center', 'align_right', 'align_justify'],
];
const DEFAULT_COLOR_PRESETS = [
    '#b60205',
    '#d93f0b',
    '#fbca04',
    '#0e8a16',
    '#006b75',
    '#1d76db',
    '#0052cc',
    '#5319e7',
    '#e99695',
    '#f9d0c4',
    '#fef2c0',
    '#c2e0c6',
    '#bfdadc',
    '#c5def5',
    '#bfd4f2',
    '#d4c5f9'
];
const DEFAULT_MENU = {
    toolbar: DEFAULT_TOOLBAR,
    colorPresets: []
};
const DEFAULT_SCHEMA = schema;
const DEFAULT_PLUGINS = [];
class NgxEditorServiceConfig {
    constructor() {
        this.plugins = DEFAULT_PLUGINS;
        this.nodeViews = {};
        this.schema = DEFAULT_SCHEMA;
        this.menu = DEFAULT_MENU;
        this.locals = {};
    }
}
NgxEditorServiceConfig.ɵprov = ɵɵdefineInjectable({ factory: function NgxEditorServiceConfig_Factory() { return new NgxEditorServiceConfig(); }, token: NgxEditorServiceConfig, providedIn: "root" });
NgxEditorServiceConfig.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
class NgxEditorService {
    constructor(config) {
        this.config = config;
    }
    get locals() {
        return new Locals(this.config.locals);
    }
    get menu() {
        return this.config.menu;
    }
    get colorPresets() {
        const col = 8;
        const colors = [];
        const { colorPresets } = this.config.menu;
        const allColors = colorPresets.length ? colorPresets : DEFAULT_COLOR_PRESETS;
        allColors.forEach((color, index) => {
            const row = Math.floor(index / col);
            if (!colors[row]) {
                colors.push([]);
            }
            colors[row].push(color);
        });
        return colors;
    }
}
NgxEditorService.ɵprov = ɵɵdefineInjectable({ factory: function NgxEditorService_Factory() { return new NgxEditorService(ɵɵinject(NgxEditorServiceConfig, 8)); }, token: NgxEditorService, providedIn: "root" });
NgxEditorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
NgxEditorService.ctorParameters = () => [
    { type: NgxEditorServiceConfig, decorators: [{ type: Optional }] }
];
const provideMyServiceOptions = (config) => {
    var _a, _b, _c, _d;
    let menu;
    if (config.menu !== null) {
        if (!config.menu) {
            menu = DEFAULT_MENU;
        }
        else if (Array.isArray(config.menu)) {
            menu = Object.assign(Object.assign({}, DEFAULT_MENU), { toolbar: config.menu });
        }
        else {
            menu = Object.assign(Object.assign({}, DEFAULT_MENU), config.menu);
        }
    }
    return {
        plugins: (_a = config === null || config === void 0 ? void 0 : config.plugins) !== null && _a !== void 0 ? _a : DEFAULT_PLUGINS,
        nodeViews: (_b = config === null || config === void 0 ? void 0 : config.nodeViews) !== null && _b !== void 0 ? _b : {},
        menu,
        schema: (_c = config === null || config === void 0 ? void 0 : config.schema) !== null && _c !== void 0 ? _c : DEFAULT_SCHEMA,
        locals: (_d = config.locals) !== null && _d !== void 0 ? _d : {}
    };
};

var _view;
class SharedService {
    constructor() {
        _view.set(this, void 0);
        this.customMenuRefChange = new Subject();
        this.plugin = {
            update: new Subject(),
            destroy: new Subject()
        };
    }
    set view(v) {
        __classPrivateFieldSet(this, _view, v);
    }
    get view() {
        return __classPrivateFieldGet(this, _view);
    }
    setCustomMenuRef(c) {
        this.customMenuRefChange.next(c);
    }
}
_view = new WeakMap();
SharedService.ɵprov = ɵɵdefineInjectable({ factory: function SharedService_Factory() { return new SharedService(); }, token: SharedService, providedIn: "root" });
SharedService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
SharedService.ctorParameters = () => [];

// https://developer.mozilla.org/en-US/docs/Web/API/DocumentFragment
const toHTML = (json, inputSchema) => {
    const schema$1 = inputSchema !== null && inputSchema !== void 0 ? inputSchema : schema;
    const contentNode = schema$1.nodeFromJSON(json);
    const html = DOMSerializer.fromSchema(schema$1).serializeFragment(contentNode.content);
    const div = document.createElement('div');
    div.appendChild(html);
    return div.innerHTML;
};
const toDoc = (html, inputSchema) => {
    const schema$1 = inputSchema !== null && inputSchema !== void 0 ? inputSchema : schema;
    const el = document.createElement('div');
    el.innerHTML = html;
    return DOMParser.fromSchema(schema$1).parse(el).toJSON();
};
const parseValue = (value, schema) => {
    if (!value) {
        return null;
    }
    if (typeof value !== 'string') {
        return schema.nodeFromJSON(value);
    }
    const docJson = toDoc(value, schema);
    return schema.nodeFromJSON(docJson);
};

class NgxEditorComponent {
    constructor(ngxEditorService, sharedService) {
        this.sharedService = sharedService;
        this.editorInitialized = false;
        this.placeholder = 'Type here...';
        this.editable = true;
        this.init = new EventEmitter();
        this.focusOut = new EventEmitter();
        this.focusIn = new EventEmitter();
        this.config = ngxEditorService.config;
    }
    get toolbar() {
        var _a;
        return (_a = this.config.menu) === null || _a === void 0 ? void 0 : _a.toolbar;
    }
    writeValue(value) {
        if (!this.editorInitialized) {
            return;
        }
        if (!this.outputFormat && typeof value === 'string') {
            this.outputFormat = 'html';
        }
        this.updateContent(value);
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    updateContent(value) {
        try {
            const { state } = this.view;
            const { tr, doc } = state;
            const newDoc = parseValue(value, this.config.schema);
            tr.replaceWith(0, state.doc.content.size, newDoc)
                .setMeta('PREVENT_ONCHANGE', true);
            // don't emit if both content is same
            if (doc !== null && doc.eq(tr.doc)) {
                return;
            }
            if (!tr.docChanged) {
                return;
            }
            this.view.dispatch(tr);
        }
        catch (err) {
            console.error('Unable to update document.', err);
        }
    }
    handleTransactions(tr) {
        const { state } = this.view.state.applyTransaction(tr);
        this.view.updateState(state);
        if (!tr.docChanged || !this.onChange || tr.getMeta('PREVENT_ONCHANGE')) {
            return;
        }
        const json = state.doc.toJSON();
        if (this.outputFormat === 'html') {
            const html = toHTML(json, this.config.schema);
            this.onChange(html);
            return;
        }
        this.onChange(json);
    }
    createUpdateWatcherPlugin() {
        const plugin = new Plugin({
            key: new PluginKey('ngx-update-watcher'),
            view: () => {
                return {
                    update: (view) => this.sharedService.plugin.update.next(view),
                    destroy: () => this.sharedService.plugin.destroy.next()
                };
            }
        });
        return plugin;
    }
    filterBuiltIns(plugin) {
        const pluginKey = plugin.key;
        if (/^(editable|placeholder)\$/.test(pluginKey)) {
            return false;
        }
        return true;
    }
    createEditor() {
        const { schema, plugins, nodeViews } = this.config;
        this.view = new EditorView(this.ngxEditor.nativeElement, {
            state: EditorState.create({
                doc: null,
                schema,
                plugins: [
                    ...plugins.filter((plugin) => this.filterBuiltIns(plugin)),
                    this.createUpdateWatcherPlugin(),
                    placeholder(this.placeholder),
                    editable(this.editable)
                ]
            }),
            nodeViews,
            dispatchTransaction: this.handleTransactions.bind(this),
            handleDOMEvents: {
                focus: () => {
                    this.focusIn.emit();
                    return false;
                },
                blur: () => {
                    this.onTouched();
                    this.focusOut.emit();
                    return false;
                }
            },
            attributes: {
                class: 'NgxEditor__Content'
            },
        });
        this.editorInitialized = true;
        this.sharedService.view = this.view;
        this.sharedService.setCustomMenuRef(this.customMenuRef);
        this.init.emit(this.view);
    }
    setPlaceholder(newPlaceholder) {
        const { dispatch, state: { tr } } = this.view;
        const placeholder = newPlaceholder !== null && newPlaceholder !== void 0 ? newPlaceholder : this.placeholder;
        dispatch(tr.setMeta('UPDATE_PLACEHOLDER', placeholder));
    }
    updateEditable(edit) {
        const { dispatch, state: { tr } } = this.view;
        dispatch(tr.setMeta('UPDATE_EDITABLE', edit));
    }
    ngOnInit() {
        this.createEditor();
        this.setPlaceholder();
    }
    ngOnChanges(changes) {
        if ((changes === null || changes === void 0 ? void 0 : changes.placeholder) && !changes.placeholder.isFirstChange()) {
            this.setPlaceholder(changes.placeholder.currentValue);
        }
        if ((changes === null || changes === void 0 ? void 0 : changes.editable) && !changes.editable.isFirstChange()) {
            this.updateEditable(changes.editable.currentValue);
        }
    }
    ngOnDestroy() {
        this.view.destroy();
    }
}
NgxEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-editor',
                template: "<div class=\"NgxEditor\" #ngxEditor>\n  <ngx-menu \n    [toolbar]=\"toolbar\" \n    [editorView]=\"view\"\n    *ngIf=\"toolbar\"\n    [disabled]=\"!editable\"\n  >\n  </ngx-menu>\n  <ngx-bubble></ngx-bubble>\n</div>\n",
                providers: [{
                        provide: NG_VALUE_ACCESSOR,
                        useExisting: forwardRef(() => NgxEditorComponent),
                        multi: true
                    }],
                encapsulation: ViewEncapsulation.None,
                styles: [".NgxEditor{background:#fff;background-clip:padding-box;border:2px solid rgba(0,0,0,.2);border-radius:4px;color:#000;overflow:hidden;position:relative}.NgxEditor--Disabled{opacity:.5;pointer-events:none}.NgxEditor__Placeholder{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;color:#6c757d;cursor:text;opacity:1;position:absolute;user-select:none}.NgxEditor__Content{padding:.5rem;white-space:pre-wrap}.NgxEditor__Content p{margin:0 0 .7rem}.NgxEditor__Content blockquote{border-left:3px solid #ddd;margin-left:0;margin-right:0;padding-left:1rem}.NgxEditor__Content--Disabled{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;pointer-events:none;user-select:none}.NgxEditor__ImageWrapper{display:inline-block;line-height:0;padding:2px;position:relative}.NgxEditor__ImageWrapper.NgxEditor__Resizer--Active{border:1px solid #1a73e8;padding:1px}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle{display:none;height:100%;position:absolute;width:100%}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BL,.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BR,.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TL,.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TR{background-color:#1a73e8;border:1px solid #fff;height:7px;position:absolute;width:7px}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BR{bottom:-5px;cursor:se-resize;right:-5px}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TR{cursor:ne-resize;right:-5px;top:-5px}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--TL{cursor:nw-resize;left:-5px;top:-5px}.NgxEditor__ImageWrapper .NgxEditor__ResizeHandle .NgxEditor__ResizeHandle--BL{bottom:-5px;cursor:sw-resize;left:-5px}.ProseMirror{outline:none}.NgxEditor__HelpText{font-size:80%}.NgxEditor__HelpText.NgxEditor__HelpText--Error{color:red}"]
            },] }
];
NgxEditorComponent.ctorParameters = () => [
    { type: NgxEditorService },
    { type: SharedService }
];
NgxEditorComponent.propDecorators = {
    ngxEditor: [{ type: ViewChild, args: ['ngxEditor', { static: true },] }],
    outputFormat: [{ type: Input }],
    customMenuRef: [{ type: Input }],
    placeholder: [{ type: Input }],
    editable: [{ type: Input }],
    init: [{ type: Output }],
    focusOut: [{ type: Output }],
    focusIn: [{ type: Output }]
};

class MenuComponent {
    constructor(sharedService) {
        this.sharedService = sharedService;
        this.disabled = false;
        this.customMenuRef = null;
        this.simpleCommands = [
            'bold', 'italic',
            'underline', 'strike',
            'code', 'blockquote',
            'ordered_list', 'bullet_list',
            'align_left', 'align_center', 'align_right', 'align_justify'
        ];
        this.iconContainerClass = ['NgxEditor__MenuItem', 'NgxEditor__MenuItem--Icon'];
        this.dropdownContainerClass = ['NgxEditor__Dropdown'];
        this.seperatorClass = ['NgxEditor__Seperator'];
        this.customMenuRefSubscription = this.sharedService.customMenuRefChange.subscribe((ref) => {
            this.customMenuRef = ref;
        });
    }
    isDropDown(item) {
        if (typeof item === 'object') {
            return true;
        }
        return false;
    }
    ngOnDestroy() {
        this.customMenuRefSubscription.unsubscribe();
    }
}
MenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-menu',
                template: "<div class=\"NgxEditor__MenuBar\" [ngClass]=\"{'NgxEditor--Disabled': disabled}\">\n\n  <ng-container *ngFor=\"let toolbarItem of toolbar; let lastToolbarItem = last\">\n    <ng-container *ngFor=\"let item of toolbarItem; let lastItem = last\">\n\n      <!-- simple icons -->\n      <ngx-simple-command [name]=\"item\" [class]=\"iconContainerClass\" *ngIf=\"simpleCommands.includes(item)\">\n      </ngx-simple-command>\n\n      <!-- link -->\n      <ngx-link [name]=\"item\" [class]=\"iconContainerClass\" *ngIf=\"item === 'link'\">\n      </ngx-link>\n\n      <!-- image -->\n      <ngx-image [name]=\"item\" [class]=\"iconContainerClass\" *ngIf=\"item === 'image'\">\n      </ngx-image>\n\n      <!-- dropdown -->\n      <ng-container *ngIf=\"isDropDown(item)\">\n        <ng-container *ngFor=\"let dropdown of item | keyvalue\">\n          <ngx-dropdown [class]=\"dropdownContainerClass\" [group]=\"dropdown.key\" [items]=\"dropdown.value\">\n          </ngx-dropdown>\n        </ng-container>\n      </ng-container>\n\n      <!-- text color picker -->\n      <ngx-color-picker [class]=\"iconContainerClass\" *ngIf=\"item === 'text_color'\" type=\"text_color\">\n      </ngx-color-picker>\n      <!-- background color picker -->\n      <ngx-color-picker [class]=\"iconContainerClass\" *ngIf=\"item === 'background_color'\" type=\"background_color\">\n      </ngx-color-picker>\n\n      <!-- seperator -->\n      <div [class]=\"seperatorClass\" *ngIf=\"lastItem && !lastToolbarItem\"></div>\n    </ng-container>\n  </ng-container>\n\n  <!-- custom menu -->\n  <ng-container *ngIf=\"customMenuRef\">\n    <ng-container [ngTemplateOutlet]=\"customMenuRef\"></ng-container>\n  </ng-container>\n\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".NgxEditor__MenuBar{border-bottom:1px solid #ddd;cursor:default;display:flex;height:1.85rem;padding:.2rem}.NgxEditor__MenuItem{align-items:center;border-radius:2px;display:flex;flex-shrink:0;justify-content:center;position:relative}.NgxEditor__MenuItem:hover{background-color:#f1f1f1}.NgxEditor__MenuItem.NgxEditor__MenuItem--Icon{height:1.85rem;transition:.3s ease-in-out;width:1.85rem}.NgxEditor__MenuItem.NgxEditor__MenuItem--Icon+.NgxEditor__MenuItem--Icon{margin-left:2px}.NgxEditor__MenuItem .NgxEditor__MenuItem--IconContainer{align-items:center;display:flex;height:100%;justify-content:center;width:100%}.NgxEditor__MenuItem.NgxEditor__MenuItem--Text{padding:0 .3rem}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active{background-color:#e8f0fe}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active.NgxEditor__MenuItem--Text{color:#1a73e8}.NgxEditor__MenuItem.NgxEditor__MenuItem--Active svg{fill:#1a73e8}.NgxEditor__Dropdown{align-items:center;display:flex;flex-shrink:0;min-width:4rem;position:relative}.NgxEditor__Dropdown:hover{background-color:#f1f1f1}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text{align-items:center;display:flex;height:100%;justify-content:center;padding:0 .3rem;width:100%}.NgxEditor__Dropdown .NgxEditor__Dropdown--Text:after{border-bottom:0;border-left:.25rem solid transparent;border-right:.25rem solid transparent;border-top:.25rem solid;content:\"\";display:inline-block;margin-left:1.5rem;vertical-align:.25rem}.NgxEditor__Dropdown .NgxEditor__Dropdown--DropdownMenu{background-color:#fff;border-radius:4px;box-shadow:0 2px 6px 2px rgba(60,64,67,.15);left:0;position:absolute;top:calc(1.85rem + 2px);width:100%;z-index:10}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item{color:inherit;padding:.5rem;white-space:nowrap}.NgxEditor__Dropdown .NgxEditor__Dropdown--Item:hover{background-color:#ececec}.NgxEditor__Dropdown.NgxEditor__Dropdown--Open,.NgxEditor__Dropdown.NgxEditor__Dropdown--Selected{background-color:#e8f0fe}.NgxEditor__Dropdown.NgxEditor__Dropdown--Open .NgxEditor__Dropdown--Text,.NgxEditor__Dropdown.NgxEditor__Dropdown--Selected .NgxEditor__Dropdown--Text{color:#1a73e8}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active{background-color:#f1f1f1}.NgxEditor__Dropdown .NgxEditor__Dropdown--Active:hover{background-color:#e7e7e7}.NgxEditor__Popup{background-color:#fff;border-radius:4px;box-shadow:0 2px 6px 2px rgba(60,64,67,.15);min-width:12rem;padding:8px;position:absolute;top:calc(1.85rem + 2px);z-index:10}.NgxEditor__Popup .NgxEditor__Popup--FormGroup{margin-bottom:8px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup label{margin-bottom:3px}.NgxEditor__Popup .NgxEditor__Popup--FormGroup input[type=text],.NgxEditor__Popup .NgxEditor__Popup--FormGroup input[type=url]{padding:2px 4px}.NgxEditor__Popup .NgxEditor__Popup--Col{display:flex;flex-direction:column;position:relative}.NgxEditor__Popup .NgxEditor__Popup--Label{font-size:85%}.NgxEditor__Seperator{border-left:1px solid #ccc;margin:0 .3rem}"]
            },] }
];
MenuComponent.ctorParameters = () => [
    { type: SharedService }
];
MenuComponent.propDecorators = {
    toolbar: [{ type: Input }],
    editorView: [{ type: Input }],
    disabled: [{ type: Input }]
};

class MarkToggle {
    constructor(name) {
        this.name = name;
    }
    execute(state, dispatch) {
        const { schema } = state;
        const type = schema.marks[this.name];
        if (!type) {
            return false;
        }
        return toggleMark(type)(state, dispatch);
    }
    isActive(state) {
        const { schema } = state;
        const type = schema.marks[this.name];
        if (!type) {
            return false;
        }
        return isMarkActive(state, type);
    }
    canExecute(state) {
        return this.execute(state, null);
    }
}

class BlockqoteToggle {
    execute(state, dispatch) {
        const { schema } = state;
        const type = schema.nodes.blockquote;
        if (!type) {
            return false;
        }
        if (this.isActive(state)) {
            return lift(state, dispatch);
        }
        return wrapIn(type)(state, dispatch);
    }
    isActive(state) {
        const { schema } = state;
        const type = schema.nodes.blockquote;
        if (!type) {
            return false;
        }
        return isNodeActive(state, type);
    }
    canExecute(state) {
        return this.execute(state, null);
    }
}

class ListItemToggle {
    constructor(isBulletList = false) {
        this.isBulletList = false;
        this.isBulletList = isBulletList;
    }
    getType(schema) {
        return this.isBulletList ? schema.nodes.bullet_list : schema.nodes.ordered_list;
    }
    execute(state, dispatch) {
        const { schema } = state;
        const type = this.getType(schema);
        if (!type) {
            return false;
        }
        if (this.isActive(state)) {
            return liftListItem(schema.nodes.list_item)(state, dispatch);
        }
        return wrapInList(type)(state, dispatch);
    }
    isActive(state) {
        const { schema } = state;
        const type = this.getType(schema);
        if (!type) {
            return false;
        }
        return isNodeActive(state, type);
    }
    canExecute(state) {
        return this.execute(state, null);
    }
}

class Heading {
    constructor(level) {
        this.level = level;
    }
    execute(state, dispatch) {
        var _a;
        const { schema, selection, doc } = state;
        const type = schema.nodes.heading;
        if (!type) {
            return false;
        }
        const nodePos = selection.$from.before(1);
        const node = doc.nodeAt(nodePos);
        const attrs = (_a = node === null || node === void 0 ? void 0 : node.attrs) !== null && _a !== void 0 ? _a : {};
        if (this.isActive(state)) {
            return setBlockType(schema.nodes.paragraph, attrs)(state, dispatch);
        }
        return setBlockType(type, Object.assign(Object.assign({}, attrs), { level: this.level }))(state, dispatch);
    }
    isActive(state) {
        const { schema } = state;
        const nodesInSelection = getSelectionNodes(state);
        const type = schema.nodes.heading;
        if (!type) {
            return false;
        }
        const supportedNodes = [
            type,
            schema.nodes.text,
            schema.nodes.blockquote
        ];
        // heading is a text node
        // don't mark as active when it has more nodes
        const nodes = nodesInSelection.filter(node => {
            return supportedNodes.includes(node.type);
        });
        const acitveNode = nodes.find((node) => {
            return node.attrs.level === this.level;
        });
        return Boolean(acitveNode);
    }
    canExecute(state) {
        return this.execute(state, null);
    }
}

class TextAlign {
    constructor(align) {
        this.align = align;
    }
    execute(state, dispatch) {
        const { doc, selection, tr, schema } = state;
        const { from, to } = selection;
        let applicable = false;
        doc.nodesBetween(from, to, (node, pos) => {
            const nodeType = node.type;
            if ([schema.nodes.paragraph, schema.nodes.heading].includes(nodeType)) {
                applicable = true;
                tr.setNodeMarkup(pos, nodeType, Object.assign(Object.assign({}, node.attrs), { align: this.align }));
            }
            return true;
        });
        if (!applicable) {
            return false;
        }
        if (tr.docChanged) {
            dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr);
        }
        return true;
    }
    isActive(state) {
        const nodes = getSelectionNodes(state);
        const active = nodes.find((node) => {
            return node.attrs.align === this.align;
        });
        return Boolean(active);
    }
    canExecute(state) {
        return this.execute(state, null);
    }
}

const defaultOptions = {
    strict: true
};
class Link {
    update(attrs = {}, state, dispatch) {
        const { schema } = state;
        const type = schema.marks.link;
        if (!type) {
            return false;
        }
        return toggleMark(type, attrs)(state, dispatch);
    }
    insert(text, attrs = {}, state, dispatch) {
        const { schema, tr } = state;
        const type = schema.marks.link;
        if (!type) {
            return false;
        }
        const node = schema.text(text, [schema.marks.link.create(attrs)]);
        dispatch(tr.replaceSelectionWith(node, false));
        return true;
    }
    isActive(state, options = defaultOptions) {
        if (options.strict) {
            return true;
        }
        const { schema } = state;
        return isMarkActive(state, schema.marks.link);
    }
    remove(state, dispatch) {
        return removeLink()(state, dispatch);
    }
    canExecute(state) {
        return this.update({}, state, null);
    }
}

class Image {
    execute(attrs = {}, state, dispatch) {
        const { schema, tr, selection } = state;
        const type = schema.nodes.image;
        if (!type) {
            return false;
        }
        const nodeAttrs = Object.assign(Object.assign({}, attrs), { width: null });
        if (selection instanceof NodeSelection && selection.node.type === type) {
            nodeAttrs.width = selection.node.attrs.width;
        }
        tr.replaceSelectionWith(type.createAndFill(nodeAttrs));
        if (tr.docChanged) {
            dispatch === null || dispatch === void 0 ? void 0 : dispatch(tr);
            return true;
        }
        return false;
    }
    isActive(state) {
        const { selection } = state;
        if (selection instanceof NodeSelection) {
            return selection.node.type.name === 'image';
        }
        return false;
    }
}

class TextColor {
    constructor(name) {
        this.name = name;
    }
    execute(attrs) {
        return (state, dispatch) => {
            const { schema, selection, doc } = state;
            const type = schema.marks[this.name];
            if (!type) {
                return false;
            }
            const { from, to, empty } = selection;
            if (!empty && (from + 1 === to)) {
                const node = doc.nodeAt(from);
                if (node.isAtom && !node.isText && node.isLeaf) {
                    // An atomic node (e.g. Image) is selected.
                    return false;
                }
            }
            return applyMark(type, attrs)(state, dispatch);
        };
    }
    isActive(state) {
        const { schema } = state;
        const type = schema.marks[this.name];
        if (!type) {
            return false;
        }
        return isMarkActive(state, type);
    }
    getActiveColors(state) {
        if (!this.isActive(state)) {
            return [];
        }
        const { schema } = state;
        const marks = getSelectionMarks(state);
        const colors = marks
            .filter(mark => mark.type === schema.marks[this.name])
            .map(mark => mark.attrs.color)
            .filter(Boolean);
        return colors;
    }
    remove(state, dispatch) {
        const { tr } = state;
        const { selection, schema } = state;
        const { empty, from, to } = selection;
        const type = schema.marks[this.name];
        if (!type) {
            return false;
        }
        if (empty) {
            tr.removeStoredMark(type);
        }
        else {
            tr.removeMark(from, to, type);
            if (!tr.docChanged) {
                return false;
            }
        }
        dispatch(tr.scrollIntoView());
        return true;
    }
    canExecute(state) {
        return this.execute({})(state, null);
    }
}

const STRONG = new MarkToggle('strong');
const EM = new MarkToggle('em');
const CODE = new MarkToggle('code');
const UNDERLINE = new MarkToggle('u');
const STRIKE = new MarkToggle('s');
const BLOCKQUOTE = new BlockqoteToggle();
const UL = new ListItemToggle(true);
const OL = new ListItemToggle(false);
const H1 = new Heading(1);
const H2 = new Heading(2);
const H3 = new Heading(3);
const H4 = new Heading(4);
const H5 = new Heading(5);
const H6 = new Heading(6);
const ALIGN_LEFT = new TextAlign('left');
const ALIGN_CENTER = new TextAlign('center');
const ALIGN_RIGHT = new TextAlign('right');
const ALIGN_JUSTIFY = new TextAlign('justify');
const LINK = new Link();
const IMAGE = new Image();
const TEXT_COLOR = new TextColor('text_color');
const TEXT_BACKGROUND_COLOR = new TextColor('text_background_color');

const SimpleCommands = new Map();
SimpleCommands.set('bold', STRONG);
SimpleCommands.set('italic', EM);
SimpleCommands.set('code', CODE);
SimpleCommands.set('underline', UNDERLINE);
SimpleCommands.set('strike', STRIKE);
SimpleCommands.set('blockquote', BLOCKQUOTE);
SimpleCommands.set('bullet_list', UL);
SimpleCommands.set('ordered_list', OL);
SimpleCommands.set('h1', H1);
SimpleCommands.set('h2', H2);
SimpleCommands.set('h3', H3);
SimpleCommands.set('h4', H4);
SimpleCommands.set('h5', H5);
SimpleCommands.set('h6', H6);
SimpleCommands.set('align_left', ALIGN_LEFT);
SimpleCommands.set('align_center', ALIGN_CENTER);
SimpleCommands.set('align_right', ALIGN_RIGHT);
SimpleCommands.set('align_justify', ALIGN_JUSTIFY);
const Link$1 = LINK;
const Image$1 = IMAGE;
const TextColor$1 = TEXT_COLOR;
const TextBackgroundColor = TEXT_BACKGROUND_COLOR;

/* tslint:disable */
var bold = `
  <path d="M15.6 10.79c.97-.67 1.65-1.77 1.65-2.79 0-2.26-1.75-4-4-4H7v14h7.04c2.09 0 3.71-1.7 3.71-3.79 0-1.52-.86-2.82-2.15-3.42zM10 6.5h3c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-3v-3zm3.5 9H10v-3h3.5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5z" />
  <path d="M0 0h24v24H0z" fill="none" />
`;

var italic = `
  <path d="M0 0h24v24H0z" fill="none" />
  <path d="M10 4v3h2.21l-3.42 8H6v3h8v-3h-2.21l3.42-8H18V4z" />
`;

var code$1 = `
<path d="M0 0h24v24H0V0z" fill="none"/>
<path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/>
`;

var underline = `
<path d="M0 0h24v24H0z" fill="none"/>
<path d="M12 17c3.31 0 6-2.69 6-6V3h-2.5v8c0 1.93-1.57 3.5-3.5 3.5S8.5 12.93 8.5 11V3H6v8c0 3.31 2.69 6 6 6zm-7 2v2h14v-2H5z"/>
`;

var strike = `
<path d="M6.85,7.08C6.85,4.37,9.45,3,12.24,3c1.64,0,3,0.49,3.9,1.28c0.77,0.65,1.46,1.73,1.46,3.24h-3.01 c0-0.31-0.05-0.59-0.15-0.85c-0.29-0.86-1.2-1.28-2.25-1.28c-1.86,0-2.34,1.02-2.34,1.7c0,0.48,0.25,0.88,0.74,1.21 C10.97,8.55,11.36,8.78,12,9H7.39C7.18,8.66,6.85,8.11,6.85,7.08z M21,12v-2H3v2h9.62c1.15,0.45,1.96,0.75,1.96,1.97 c0,1-0.81,1.67-2.28,1.67c-1.54,0-2.93-0.54-2.93-2.51H6.4c0,0.55,0.08,1.13,0.24,1.58c0.81,2.29,3.29,3.3,5.67,3.3 c2.27,0,5.3-0.89,5.3-4.05c0-0.3-0.01-1.16-0.48-1.94H21V12z"/>
`;

var orderedList$1 = `
<path d="M2 17h2v.5H3v1h1v.5H2v1h3v-4H2v1zm1-9h1V4H2v1h1v3zm-1 3h1.8L2 13.1v.9h3v-1H3.2L5 10.9V10H2v1zm5-6v2h14V5H7zm0 14h14v-2H7v2zm0-6h14v-2H7v2z"/>
<path d="M0 0h24v24H0z" fill="none"/>
`;

var bulletList$1 = `
<path d="M0 0h24v24H0V0z" fill="none"/>
<path d="M4 10.5c-.83 0-1.5.67-1.5 1.5s.67 1.5 1.5 1.5 1.5-.67 1.5-1.5-.67-1.5-1.5-1.5zm0-6c-.83 0-1.5.67-1.5 1.5S3.17 7.5 4 7.5 5.5 6.83 5.5 6 4.83 4.5 4 4.5zm0 12c-.83 0-1.5.68-1.5 1.5s.68 1.5 1.5 1.5 1.5-.68 1.5-1.5-.67-1.5-1.5-1.5zM7 19h14v-2H7v2zm0-6h14v-2H7v2zm0-8v2h14V5H7z"/>
`;

var quote = `
<path d="M0 0h24v24H0z" fill="none"/><path d="M6 17h3l2-4V7H5v6h3zm8 0h3l2-4V7h-6v6h3z"/>
`;

var link$1 = `
<path d="M0 0h24v24H0z" fill="none"/><path d="M3.9 12c0-1.71 1.39-3.1 3.1-3.1h4V7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1zM8 13h8v-2H8v2zm9-6h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1s-1.39 3.1-3.1 3.1h-4V17h4c2.76 0 5-2.24 5-5s-2.24-5-5-5z"/>
`;

var unlink = `
<path d="M0 0h24v24H0V0z" fill="none"/>
<path d="M17 7h-4v1.9h4c1.71 0 3.1 1.39 3.1 3.1 0 1.43-.98 2.63-2.31 2.98l1.46 1.46C20.88 15.61 22 13.95 22 12c0-2.76-2.24-5-5-5zm-1 4h-2.19l2 2H16zM2 4.27l3.11 3.11C3.29 8.12 2 9.91 2 12c0 2.76 2.24 5 5 5h4v-1.9H7c-1.71 0-3.1-1.39-3.1-3.1 0-1.59 1.21-2.9 2.76-3.07L8.73 11H8v2h2.73L13 15.27V17h1.73l4.01 4L20 19.74 3.27 3 2 4.27z"/>
<path d="M0 24V0" fill="none"/>
`;

var image$1 = `
<path d="M0 0h24v24H0z" fill="none"/>
<path d="M21 19V5c0-1.1-.9-2-2-2H5c-1.1 0-2 .9-2 2v14c0 1.1.9 2 2 2h14c1.1 0 2-.9 2-2zM8.5 13.5l2.5 3.01L14.5 12l4.5 6H5l3.5-4.5z"/>
`;

var alignLeft = `
<path d="M0 0h24v24H0z" fill="none"/>
<path d="M15 15H3v2h12v-2zm0-8H3v2h12V7zM3 13h18v-2H3v2zm0 8h18v-2H3v2zM3 3v2h18V3H3z"/>
`;

var alignCenter = `
<path d="M0 0h24v24H0z" fill="none"/>
<path d="M7 15v2h10v-2H7zm-4 6h18v-2H3v2zm0-8h18v-2H3v2zm4-6v2h10V7H7zM3 3v2h18V3H3z"/>
`;

var alignRight = `
<path d="M0 0h24v24H0z" fill="none"/>
<path d="M3 21h18v-2H3v2zm6-4h12v-2H9v2zm-6-4h18v-2H3v2zm6-4h12V7H9v2zM3 3v2h18V3H3z"/>
`;

var alignJustify = `
<path d="M0 0h24v24H0z" fill="none"/>
<path d="M3 21h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18v-2H3v2zm0-4h18V7H3v2zm0-6v2h18V3H3z"/>
`;

var textColor$1 = `
<path d="M2,20h20v4H2V20z M5.49,17h2.42l1.27-3.58h5.65L16.09,17h2.42L13.25,3h-2.5L5.49,17z M9.91,11.39l2.03-5.79h0.12l2.03,5.79 H9.91z"/>
`;

var colorFill = `
<path d="M16.56,8.94L7.62,0L6.21,1.41l2.38,2.38L3.44,8.94c-0.59,0.59-0.59,1.54,0,2.12l5.5,5.5C9.23,16.85,9.62,17,10,17 s0.77-0.15,1.06-0.44l5.5-5.5C17.15,10.48,17.15,9.53,16.56,8.94z M5.21,10L10,5.21L14.79,10H5.21z M19,11.5c0,0-2,2.17-2,3.5 c0,1.1,0.9,2,2,2s2-0.9,2-2C21,13.67,19,11.5,19,11.5z M2,20h20v4H2V20z"/>
`;

// Icons source: https://material.io/
const DEFAULT_ICON_HEIGHT = 20;
const DEFAULT_ICON_WIDTH = 20;
const icons = {
    bold,
    italic,
    code: code$1,
    underline,
    strike,
    ordered_list: orderedList$1,
    bullet_list: bulletList$1,
    blockquote: quote,
    link: link$1,
    unlink,
    image: image$1,
    align_left: alignLeft,
    align_center: alignCenter,
    align_right: alignRight,
    align_justify: alignJustify,
    text_color: textColor$1,
    color_fill: colorFill
};
class Icon {
    static get(name) {
        const path = icons[name] || '<path></path>';
        return `
      <svg
        xmlns="http://www.w3.org/2000/svg"
        viewBox="0 0 24 24"
        fill="black"
        height=${DEFAULT_ICON_HEIGHT}
        width=${DEFAULT_ICON_WIDTH}
      >
        ${path}
      </svg>
    `;
    }
}

class SimpleCommandComponent {
    constructor(ngxeService, sharedService) {
        this.ngxeService = ngxeService;
        this.sharedService = sharedService;
        this.isActive = false;
        this.disabled = false;
        this.update = (view) => {
            const { state } = view;
            const command = SimpleCommands.get(this.name);
            this.isActive = command.isActive(state);
            this.disabled = !command.canExecute(state);
        };
        this.editorView = this.sharedService.view;
        this.pluginUpdateSubscription = this.sharedService.plugin.update.subscribe((view) => {
            this.update(view);
        });
    }
    toggle(e) {
        e.preventDefault();
        if (e.button !== 0) {
            return;
        }
        const { state, dispatch } = this.editorView;
        const command = SimpleCommands.get(this.name);
        command.execute(state, dispatch);
    }
    getTitle(name) {
        return this.ngxeService.locals.get(name);
    }
    ngOnInit() {
        this.html = Icon.get(this.name);
    }
    ngOnDestroy() {
        this.pluginUpdateSubscription.unsubscribe();
    }
}
SimpleCommandComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-simple-command',
                template: "<div class=\"NgxEditor__MenuItem--IconContainer\" [innerHTML]=\"html | sanitizeHtml\" (mousedown)=\"toggle($event)\"\n  [title]=\"getTitle(name)\">\n</div>\n",
                styles: [""]
            },] }
];
SimpleCommandComponent.ctorParameters = () => [
    { type: NgxEditorService },
    { type: SharedService }
];
SimpleCommandComponent.propDecorators = {
    name: [{ type: Input }],
    isActive: [{ type: HostBinding, args: ['class.NgxEditor__MenuItem--Active',] }],
    disabled: [{ type: HostBinding, args: ['class.NgxEditor--Disabled',] }]
};

class LinkComponent {
    constructor(el, ngxeService, sharedService) {
        this.el = el;
        this.ngxeService = ngxeService;
        this.sharedService = sharedService;
        this.showPopup = false;
        this.isActive = false;
        this.canExecute = true;
        this.form = new FormGroup({
            href: new FormControl('', [
                Validators$1.required,
                Validators$1.pattern('(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?')
            ]),
            text: new FormControl('', [Validators$1.required]),
            openInNewTab: new FormControl(true)
        });
        this.setText = () => {
            const { state: { selection, doc } } = this.editorView;
            const { empty, from, to } = selection;
            const selectedText = !empty ? doc.textBetween(from, to) : '';
            if (selectedText) {
                this.text.patchValue(selectedText);
                this.text.disable();
            }
        };
        this.update = (view) => {
            const { state } = view;
            this.isActive = Link$1.isActive(state, { strict: false });
            this.canExecute = Link$1.canExecute(state);
        };
        this.editorView = this.sharedService.view;
        this.pluginUpdateSubscription = this.sharedService.plugin.update.subscribe((view) => {
            this.update(view);
        });
    }
    get valid() {
        return this.isActive || this.showPopup;
    }
    get disabled() {
        return !this.canExecute;
    }
    get icon() {
        return Icon.get(this.isActive ? 'unlink' : 'link');
    }
    get href() {
        return this.form.get('href');
    }
    get text() {
        return this.form.get('text');
    }
    onDocumentClick(e) {
        if (!this.el.nativeElement.contains(e.target) && this.showPopup) {
            this.hideForm();
        }
    }
    getLabel(key) {
        return this.ngxeService.locals.get(key);
    }
    hideForm() {
        this.showPopup = false;
        this.form.reset({
            href: '',
            text: '',
            openInNewTab: true
        });
        this.text.enable();
    }
    onMouseDown(e) {
        e.preventDefault();
        if (e.button !== 0) {
            return;
        }
        const { state, dispatch } = this.editorView;
        if (this.isActive) {
            Link$1.remove(state, dispatch);
            return;
        }
        this.showPopup = !this.showPopup;
        if (this.showPopup) {
            this.setText();
        }
    }
    insertLink(e) {
        e.preventDefault();
        const { text, href, openInNewTab } = this.form.getRawValue();
        const { dispatch, state } = this.editorView;
        const { selection } = state;
        const attrs = {
            title: href,
            href,
            target: openInNewTab ? '_blank' : '_self'
        };
        if (selection.empty) {
            Link$1.insert(text, attrs, state, dispatch);
        }
        else {
            Link$1.update(attrs, state, dispatch);
        }
        this.hideForm();
    }
    ngOnDestroy() {
        this.pluginUpdateSubscription.unsubscribe();
    }
}
LinkComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-link',
                template: "<div class=\"NgxEditor__MenuItem--IconContainer\" [innerHTML]=\"icon | sanitizeHtml\" (mousedown)=\"onMouseDown($event)\">\n</div>\n\n<!-- popup -->\n<div *ngIf=\"showPopup\" class=\"NgxEditor__Popup\">\n  <form class=\"NgxEditor__Popup--Form\" [formGroup]=\"form\" (ngSubmit)=\"insertLink($event)\">\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\">{{getLabel('url')}}</label>\n        <input type=\"href\" id=\"href\" formControlName=\"href\" autofocus autocomplete=\"off\" />\n        <div *ngIf=\"href.touched && href.invalid\" class=\"NgxEditor__HelpText NgxEditor__HelpText--Error\">\n          {{ href.errors.pattern && 'Please enter valid url.' }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\">{{getLabel('text')}}</label>\n        <input type=\"text\" formControlName=\"text\" autocomplete=\"off\" />\n        <div *ngIf=\"text.touched && text.invalid\" class=\"NgxEditor__HelpText NgxEditor__HelpText--Error\">\n          {{ text.errors.required && 'This is required' }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label>\n          <input type=\"checkbox\" formControlName=\"openInNewTab\" />\n          {{getLabel('openInNewTab')}}\n        </label>\n      </div>\n    </div>\n\n    <button type=\"submit\" [disabled]=\"!form.valid\">{{getLabel('insert')}}</button>\n\n  </form>\n</div>\n",
                styles: [""]
            },] }
];
LinkComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgxEditorService },
    { type: SharedService }
];
LinkComponent.propDecorators = {
    name: [{ type: Input }],
    valid: [{ type: HostBinding, args: ['class.NgxEditor__MenuItem--Active',] }],
    disabled: [{ type: HostBinding, args: ['class.NgxEditor--Disabled',] }],
    onDocumentClick: [{ type: HostListener, args: ['document:mousedown', ['$event'],] }]
};

class DropdownComponent {
    constructor(ngxeService, sharedService, el) {
        this.ngxeService = ngxeService;
        this.sharedService = sharedService;
        this.el = el;
        this.isDropdownOpen = false;
        this.activeItems = [];
        this.disabledItems = [];
        this.update = (view) => {
            const { state } = view;
            this.activeItems = [];
            this.disabledItems = [];
            this.items.forEach((item) => {
                const command = SimpleCommands.get(item);
                const isActive = command.isActive(state);
                if (isActive) {
                    this.activeItems.push(item);
                }
                if (!command.canExecute(state)) {
                    this.disabledItems.push(item);
                }
            });
            if (this.activeItems.length === 1) {
                this.activeItem = this.activeItems[0];
            }
            else {
                this.activeItem = null;
            }
        };
        this.editorView = this.sharedService.view;
        this.pluginUpdateSubscription = this.sharedService.plugin.update.subscribe((view) => {
            this.update(view);
        });
    }
    get isSelected() {
        return Boolean(this.activeItem || this.isDropdownOpen);
    }
    get isDropdownDisabled() {
        return this.disabledItems.length === this.items.length;
    }
    onDocumentClick(target) {
        if (!this.el.nativeElement.contains(target) && this.isDropdownOpen) {
            this.isDropdownOpen = false;
        }
    }
    getName(key) {
        return this.ngxeService.locals.get(key);
    }
    toggleDropdown(e) {
        e.preventDefault();
        this.isDropdownOpen = !this.isDropdownOpen;
    }
    onClick(e, item) {
        e.preventDefault();
        // consider only left click
        if (e.button !== 0) {
            return;
        }
        const command = SimpleCommands.get(item);
        const { state, dispatch } = this.editorView;
        command.execute(state, dispatch);
        this.isDropdownOpen = false;
    }
    ngOnInit() {
        this.selected = this.group;
    }
    ngOnDestroy() {
        this.pluginUpdateSubscription.unsubscribe();
    }
}
DropdownComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-dropdown',
                template: "<div class=\"NgxEditor__Dropdown--Text\" (mousedown)=\"toggleDropdown($event)\">\n  {{getName(activeItem || selected)}}\n</div>\n\n<div class=\"NgxEditor__Dropdown--DropdownMenu\" *ngIf=\"isDropdownOpen\">\n  <div class=\"NgxEditor__Dropdown--Item\" *ngFor=\"let item of items\" (mousedown)=\"onClick($event, item)\"\n    [ngClass]=\"{'NgxEditor__Dropdown--Active': item === activeItem, 'NgxEditor--Disabled':disabledItems.includes(item)}\">\n    {{getName(item)}}\n  </div>\n</div>\n",
                styles: [""]
            },] }
];
DropdownComponent.ctorParameters = () => [
    { type: NgxEditorService },
    { type: SharedService },
    { type: ElementRef }
];
DropdownComponent.propDecorators = {
    group: [{ type: Input }],
    items: [{ type: Input }],
    isSelected: [{ type: HostBinding, args: ['class.NgxEditor__Dropdown--Selected',] }],
    isDropdownDisabled: [{ type: HostBinding, args: ['class.NgxEditor--Disabled',] }],
    onDocumentClick: [{ type: HostListener, args: ['document:mousedown', ['$event.target'],] }]
};

class ImageComponent {
    constructor(el, ngxeService, sharedService) {
        this.el = el;
        this.ngxeService = ngxeService;
        this.sharedService = sharedService;
        this.showPopup = false;
        this.isActive = false;
        this.form = new FormGroup({
            src: new FormControl('', [
                Validators$1.required,
                Validators$1.pattern('(https?://)?([\\da-z.-]+)\\.([a-z.]{2,6})[/\\w .-]*/?')
            ]),
            alt: new FormControl(''),
            title: new FormControl('')
        });
        this.update = (view) => {
            const { state } = view;
            this.isActive = Image$1.isActive(state);
        };
        this.editorView = this.sharedService.view;
        this.pluginUpdateSubscription = this.sharedService.plugin.update.subscribe((view) => {
            this.update(view);
        });
    }
    get valid() {
        return this.isActive || this.showPopup;
    }
    get icon() {
        return Icon.get('image');
    }
    get src() {
        return this.form.get('src');
    }
    onDocumentClick(e) {
        if (!this.el.nativeElement.contains(e.target) && this.showPopup) {
            this.hideForm();
        }
    }
    getLabel(key) {
        return this.ngxeService.locals.get(key);
    }
    hideForm() {
        this.showPopup = false;
        this.form.reset({
            src: '',
            alt: '',
            title: ''
        });
    }
    onMouseDown(e) {
        e.preventDefault();
        if (e.button !== 0) {
            return;
        }
        this.showPopup = !this.showPopup;
        if (this.showPopup) {
            this.fillForm();
        }
    }
    fillForm() {
        const { state } = this.editorView;
        const { selection } = state;
        if (selection instanceof NodeSelection && this.isActive) {
            const { src, alt = '', title = '' } = selection.node.attrs;
            this.form.setValue({
                src,
                alt,
                title
            });
        }
    }
    insertLink(e) {
        e.preventDefault();
        const { src, alt, title } = this.form.getRawValue();
        const { dispatch, state } = this.editorView;
        const attrs = {
            src,
            alt,
            title
        };
        Image$1.execute(attrs, state, dispatch);
        this.hideForm();
    }
    ngOnDestroy() {
        this.pluginUpdateSubscription.unsubscribe();
    }
}
ImageComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-image',
                template: "<div class=\"NgxEditor__MenuItem--IconContainer\" [innerHTML]=\"icon | sanitizeHtml\" (mousedown)=\"onMouseDown($event)\">\n</div>\n\n<!-- popup -->\n<div *ngIf=\"showPopup\" class=\"NgxEditor__Popup\">\n  <form class=\"NgxEditor__Popup--Form\" [formGroup]=\"form\" (ngSubmit)=\"insertLink($event)\">\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\">{{getLabel('url')}}</label>\n        <input type=\"href\" id=\"href\" formControlName=\"src\" autofocus autocomplete=\"off\" />\n        <div *ngIf=\"src.touched && src.invalid\" class=\"NgxEditor__HelpText NgxEditor__HelpText--Error\">\n          {{ src.errors.pattern && 'Please enter valid url.' }}\n        </div>\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\">{{getLabel('altText')}}</label>\n        <input type=\"text\" formControlName=\"alt\" autocomplete=\"off\" />\n      </div>\n    </div>\n\n    <div class=\"NgxEditor__Popup--FormGroup\">\n      <div class=\"NgxEditor__Popup--Col\">\n        <label class=\"NgxEditor__Popup--Label\">{{getLabel('title')}}</label>\n        <input type=\"text\" formControlName=\"title\" autocomplete=\"off\" />\n      </div>\n    </div>\n\n    <button type=\"submit\" [disabled]=\"!form.valid || !form.dirty\">{{getLabel('insert')}}</button>\n\n  </form>\n</div>\n",
                styles: [""]
            },] }
];
ImageComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: NgxEditorService },
    { type: SharedService }
];
ImageComponent.propDecorators = {
    name: [{ type: Input }],
    valid: [{ type: HostBinding, args: ['class.NgxEditor__MenuItem--Active',] }],
    onDocumentClick: [{ type: HostListener, args: ['document:mousedown', ['$event'],] }]
};

class ColorPickerComponent {
    constructor(el, sharedService, ngxeService) {
        this.el = el;
        this.sharedService = sharedService;
        this.ngxeService = ngxeService;
        this.showPopup = false;
        this.isActive = false;
        this.activeColors = [];
        this.canExecute = true;
        this.update = (view) => {
            const { state } = view;
            this.canExecute = this.command.execute(null)(state);
            this.isActive = this.command.isActive(state);
            this.activeColors = [];
            if (this.isActive) {
                this.activeColors = this.command.getActiveColors(state);
            }
        };
        this.editorView = this.sharedService.view;
        this.pluginUpdateSubscription = this.sharedService.plugin.update.subscribe((view) => {
            this.update(view);
        });
    }
    get valid() {
        return this.isActive || this.showPopup;
    }
    get disabled() {
        return !this.canExecute;
    }
    get presets() {
        return this.ngxeService.colorPresets;
    }
    get title() {
        return this.getLabel(this.type === 'text_color' ? 'text_color' : 'background_color');
    }
    get icon() {
        return Icon.get(this.type === 'text_color' ? 'text_color' : 'color_fill');
    }
    get command() {
        return this.type === 'text_color' ? TextColor$1 : TextBackgroundColor;
    }
    getContrastYIQ(hexcolor) {
        hexcolor = hexcolor.replace('#', '');
        const r = parseInt(hexcolor.substr(0, 2), 16);
        const g = parseInt(hexcolor.substr(2, 2), 16);
        const b = parseInt(hexcolor.substr(4, 2), 16);
        const yiq = ((r * 299) + (g * 587) + (b * 114)) / 1000;
        return (yiq >= 128) ? 'black' : 'white';
    }
    onDocumentClick(e) {
        if (!this.el.nativeElement.contains(e.target) && this.showPopup) {
            this.hidePopup();
        }
    }
    hidePopup() {
        this.showPopup = false;
    }
    togglePopup(e) {
        e.preventDefault();
        if (e.button !== 0) {
            return;
        }
        this.showPopup = !this.showPopup;
    }
    remove(e) {
        e.preventDefault();
        const { state, dispatch } = this.editorView;
        this.command.remove(state, dispatch);
        this.hidePopup();
    }
    onColorSelect(e, color) {
        e.preventDefault();
        if (e.button !== 0) {
            return;
        }
        const { state, dispatch } = this.editorView;
        const attrs = {};
        if (this.type === 'text_color') {
            attrs.color = color;
        }
        else {
            attrs.backgroundColor = color;
        }
        this.command.execute(attrs)(state, dispatch);
        if (!this.editorView.hasFocus()) {
            this.editorView.focus();
        }
        this.hidePopup();
    }
    getLabel(key) {
        return this.ngxeService.locals.get(key);
    }
    ngOnDestroy() {
        this.pluginUpdateSubscription.unsubscribe();
    }
}
ColorPickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-color-picker',
                template: "<div class=\"NgxEditor__MenuItem--IconContainer\" [innerHTML]=\"icon | sanitizeHtml\" (mousedown)=\"togglePopup($event)\"\n  [title]=\"title\">\n</div>\n\n<div *ngIf=\"showPopup\" class=\"NgxEditor__Popup\">\n  <div *ngFor=\"let colorGroup of presets\" class=\"NgxEditor__ColorContainer\">\n    <button class=\"NgxEditor__Color\" *ngFor=\"let color of colorGroup\"\n      [ngStyle]=\"{backgroundColor: color, color:getContrastYIQ(color)}\" [title]=\"color\"\n      (mousedown)=\"onColorSelect($event, color)\"\n      [ngClass]=\"{'NgxEditor__Color--Active': activeColors.includes(color)}\"></button>\n  </div>\n\n  <button class=\"NgxEditor__MenuItem--Button\" (mousedown)=\"remove($event)\" [disabled]=\"!isActive\">\n    {{getLabel('remove')}}\n  </button>\n</div>\n",
                styles: ["@charset \"UTF-8\";.NgxEditor__Popup{width:230px}.NgxEditor__ColorContainer{display:flex;justify-content:space-between}.NgxEditor__ColorContainer+.NgxEditor__ColorContainer{margin-top:5px}.NgxEditor__Color{border:none;border-radius:6px;flex-shrink:0;height:24px;outline:none;width:24px}.NgxEditor__Color--Active:after{content:\"\u2714\";font-size:90%}.NgxEditor__MenuItem--Button{margin-top:5px}"]
            },] }
];
ColorPickerComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: SharedService },
    { type: NgxEditorService }
];
ColorPickerComponent.propDecorators = {
    valid: [{ type: HostBinding, args: ['class.NgxEditor__MenuItem--Active',] }],
    disabled: [{ type: HostBinding, args: ['class.NgxEditor--Disabled',] }],
    type: [{ type: Input }],
    onDocumentClick: [{ type: HostListener, args: ['document:mousedown', ['$event'],] }]
};

class SanitizeHtmlPipe {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
    }
    transform(value) {
        return this.sanitizer.bypassSecurityTrustHtml(value);
    }
}
SanitizeHtmlPipe.decorators = [
    { type: Pipe, args: [{
                name: 'sanitizeHtml'
            },] }
];
SanitizeHtmlPipe.ctorParameters = () => [
    { type: DomSanitizer }
];

class MenuModule {
}
MenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    ReactiveFormsModule
                ],
                declarations: [
                    // pipes
                    SanitizeHtmlPipe,
                    // components
                    MenuComponent,
                    SimpleCommandComponent,
                    LinkComponent,
                    DropdownComponent,
                    ImageComponent,
                    ColorPickerComponent
                ],
                exports: [MenuComponent],
            },] }
];

class BubbleComponent {
    constructor(sharedService, el, renderer) {
        this.sharedService = sharedService;
        this.el = el;
        this.renderer = renderer;
        this.pluginUpdateSubscription = this.sharedService.plugin.update.subscribe((view) => {
            this.view = view;
            this.update(view);
        });
    }
    setDomPosition(view) {
        // Otherwise, reposition it and update its content
        this.showBubble();
        const { bottom, left } = calculateBubblePos(view, this.el.nativeElement);
        this.renderer.setStyle(this.el.nativeElement, 'left', `${left}px`);
        this.renderer.setStyle(this.el.nativeElement, 'bottom', `${bottom}px`);
    }
    showBubble() {
        this.renderer.setStyle(this.el.nativeElement, 'display', '');
    }
    hideBubble() {
        this.renderer.setStyle(this.el.nativeElement, 'display', 'none');
    }
    removeLink() {
        const { state, dispatch } = this.view;
        removeLink()(state, dispatch);
        this.view.focus();
    }
    update(view) {
        const { state } = view;
        const { schema, selection } = state;
        if (!schema.marks.link) {
            return;
        }
        if (selection instanceof NodeSelection) {
            if (selection.node.type.name === 'image') {
                return;
            }
        }
        const hasFocus = view.hasFocus();
        const isActive = isLinkActive(state);
        const linkMarks = getSelectionMarks(state).filter(mark => mark.type === schema.marks.link);
        // hide for selection and show only for clicks
        if (!hasFocus || !isActive) {
            this.hideBubble();
            return;
        }
        const [linkItem] = linkMarks;
        this.activeLinkItem = linkItem;
        // update dom position
        this.setDomPosition(view);
    }
    ngOnInit() {
    }
    ngOnDestroy() {
        this.pluginUpdateSubscription.unsubscribe();
    }
}
BubbleComponent.decorators = [
    { type: Component, args: [{
                selector: 'ngx-bubble',
                template: "<ng-container *ngIf=\"activeLinkItem\">\n  <a [href]=\"activeLinkItem.attrs.href\" target=\"_blank\" [title]=\"activeLinkItem.attrs.href\">\n    {{activeLinkItem.attrs.href}}\n  </a>\n  <div class=\"commands\">\n    <button class=\"command\" (click)=\"removeLink()\">Remove link</button>\n  </div>\n</ng-container>\n",
                styles: [":host{align-items:center;background:#fff;border:1px solid silver;border-radius:4px;display:flex;margin-bottom:.3rem;padding:.3rem;position:absolute;transform:translateX(-50%);z-index:20}:host:after,:host:before{border:solid transparent;border-width:5px 5px 0;content:\"\";height:0;left:50%;margin-left:-5px;position:absolute;width:0}:host:before{border-top-color:silver;bottom:-6px}:host:after{border-top-color:#fff;bottom:-4.5px}:host a{display:inline-block;margin-left:2px;max-width:15rem;overflow:hidden;text-overflow:ellipsis}:host .commands{display:flex;margin-left:.5rem}:host .commands .command{background-color:#f1f1f1;border:none;border-radius:2px;display:flex;padding:2px;white-space:nowrap}:host .commands .command:hover{text-decoration:underline}"]
            },] }
];
BubbleComponent.ctorParameters = () => [
    { type: SharedService },
    { type: ElementRef },
    { type: Renderer2 }
];

const NGX_EDITOR_CONFIG_TOKEN = new InjectionToken('NgxEditorConfig');
class NgxEditorModule {
    static forRoot(config) {
        return {
            ngModule: NgxEditorModule,
            providers: [
                {
                    provide: NGX_EDITOR_CONFIG_TOKEN,
                    useValue: config
                },
                {
                    provide: NgxEditorServiceConfig,
                    useFactory: provideMyServiceOptions,
                    deps: [NGX_EDITOR_CONFIG_TOKEN]
                }
            ]
        };
    }
}
NgxEditorModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MenuModule,
                ],
                providers: [
                    SharedService
                ],
                declarations: [
                    NgxEditorComponent,
                    BubbleComponent
                ],
                exports: [NgxEditorComponent],
                entryComponents: [BubbleComponent]
            },] }
];

function isEmptyInputValue(value) {
    // we don't check for string here so it also works with arrays
    return value == null || value.length === 0;
}
function hasValidLength(value) {
    // non-strict comparison is intentional, to check for both `null` and `undefined` values
    return value != null && typeof value.length === 'number';
}
// @dynamic
class Validators {
    static required(userSchema) {
        return (control) => {
            var _a;
            const schema$1 = userSchema || schema;
            const doc = parseValue(control.value, schema$1);
            const isEmpty = doc.childCount === 1
                && ((_a = doc === null || doc === void 0 ? void 0 : doc.firstChild) === null || _a === void 0 ? void 0 : _a.isTextblock)
                && doc.firstChild.content.size === 0;
            if (!isEmpty) {
                return null;
            }
            return {
                required: true
            };
        };
    }
    static maxLength(maxLength, userSchema) {
        return (control) => {
            const schema$1 = userSchema || schema;
            const doc = parseValue(control.value, schema$1);
            const value = doc.textContent;
            if (hasValidLength(value) && value.length > maxLength) {
                return {
                    maxlength: {
                        requiredLength: maxLength,
                        actualLength: value.length
                    }
                };
            }
            return null;
        };
    }
    static minLength(minLength, userSchema) {
        return (control) => {
            const schema$1 = userSchema || schema;
            const doc = parseValue(control.value, schema$1);
            const value = doc.textContent;
            if (isEmptyInputValue(value) || !hasValidLength(value)) {
                // don't validate empty values to allow optional controls
                // don't validate values without `length` property
                return null;
            }
            if (value.length < minLength) {
                return {
                    minlength: {
                        requiredLength: minLength, actualLength: value.length
                    }
                };
            }
            return null;
        };
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { NgxEditorComponent, NgxEditorModule, Validators, makrs as marks, nodes, parseValue, schema, toDoc, toHTML, NgxEditorServiceConfig as ɵa, NgxEditorService as ɵb, provideMyServiceOptions as ɵc, SharedService as ɵd, MenuModule as ɵe, SanitizeHtmlPipe as ɵf, MenuComponent as ɵg, SimpleCommandComponent as ɵh, LinkComponent as ɵi, DropdownComponent as ɵj, ImageComponent as ɵk, ColorPickerComponent as ɵl, BubbleComponent as ɵm };
//# sourceMappingURL=ngx-editor.js.map
